# Author: Geoff Mayhew
# Here, we will see the effects that alternate stratification schemes have on our allocation methods.
# In addition, we will have to tweak our current allocation methods to be compatible with new stratification 
# schemes.


# TODO LIST

# [ ] re-run allocation_evaluation/data_prep.R
# [ ] Also in data_prep, make sure TRIP_IDs are sequenced from 1 on onward with as few gaps as possible.
# [ ] Make min_plus_opt() allow user to specify which metrics to use
# [ ] Get the mixed-gear stratification (w/ and w/out BSAI_GOA) through the allocation schemes
# [X] Make a function to update strata for trips_melt
# [X] Get cost-weighted boxes to play with updated stratification schemes as well
# [ ] Make a gear-specific version of calcualte_cwb_Ph()
# [ ] Find the best way to present results - toggle-able tables and figures in html markdown?

#======================================================================================================================#
# Preparation ----------------------------------------------------------------------------------------------------------
#======================================================================================================================#

#===================#
## Load Packages ----
#===================#

library(data.table)         # Data wrangling
library(ggplot2)            # Plotting
library(sf)                 # Spatial analyses
library(flextable)          # For print-ready tables
library(dplyr)              # For piping and handling sf objects


#=============================#
## Load data and data prep ----
#=============================#

# Fishing effort data from 2018 to 2022
# `spatiotemporal_boxes.rdata' is generated by /analyses/spatiotemporal_boxes/data_prep.R
# TODO rerun allocation_evaluation/data_prep.R to get updated version of allocation_evaluation.Rdata with crab PSC
load("analyses/allocation_evaluation/allocation_evaluation.Rdata")   # loads pc_effort_dt and trips_melt
val_2018_2022_dt <- pc_effort_dt[ADP %in% 2018:2022]

# Load the ADFG statistical area shapefile. '../' is needed for Rmarkdown to climb into parent folders.
stat_area_sf <- st_read(
  dsn = "source_data/ADFG_Stat_Area_shapefile/PVG_Statewide_2001_Present_GCS_WGS1984.shp", quiet = T) %>%
  select(STAT_AREA) %>%
  st_transform(crs = 3467)

# Load the Alaska map sf objects
load("source_data/ak_shp.rdata")      # shp_land, shp_nmfs, and shp_centroids added to global

sample_rate_vec <- seq(from = 0.005, to = 0.95, by = 0.0001) 

  
#================#
## Trip Costs ----
#================#

# Use average values from the 2023 Final ADP for now. Also, roughly using trip_end - trip_start + 1 for now until we get
# a better handle on future monitoring costs.
ob_cpd <- 4896623 / 3094         # $1582.619/day
fgem_cpd <- 1e6 / (1040+735)     # $ 563.380/day
trwem_cpd <- 600                 # $600/day according to JF estimates used in set_budget.R in 2022 Final ADP repo

trip_cost_dt <- unique(val_2018_2022_dt[, .(ADP, STRATA, TRIP_ID, DAYS)])[, .(MEAN_TRIP_DAYS = mean(DAYS)), keyby = .(ADP, STRATA)]

# Merge in day costs
trip_cost_dt[, CPD := fcase(
  STRATA == "EM_TRW", trwem_cpd,
  STRATA %in% c("EM_POT", "EM_HAL"), fgem_cpd,
  STRATA %in% c("OB_HAL", "OB_POT", "OB_TRW"), ob_cpd)]
# Calculate cost per trip
trip_cost_dt[, CPT := MEAN_TRIP_DAYS * CPD]
trip_cost_dt[STRATA == "ZERO", ':=' (CPD = 0, CPT = 0)]

#===============================#
## Prepare trips_melt object ----
#===============================#

# trips_melt has metrics and trip duration for all trips >= 2015. . 
# Add ADP year, STRATA, and DAYS of each TRIP_ID to trips_melt
trips_melt_add_data <- unique(pc_effort_dt[STRATA != "ZERO", .(ADP, TRIP_ID, STRATA, DAYS)])
trips_melt <- trips_melt_add_data[trips_melt, on = .(TRIP_ID)]
setcolorder(trips_melt, c("ADP", "STRATA", "TRIP_ID", "DAYS", "Metric", "Value"))
setkey(trips_melt, ADP, STRATA, TRIP_ID, DAYS, Metric, Value)
# Error-check
if(nrow(trips_melt[, .N, by = .(TRIP_ID)][N != 3])) stop("At least one trip has number of metrics != 3!")
# Remove records missing data
trips_melt <- trips_melt[!is.na(ADP)]

# a <- trips_melt[is.na(ADP), unique(wd_TRIP_ID)]
# length(a)  # 12,879 trips 
# # load("source_data/2024_Draft_ADP_data.rdata");   # loads 'work.data'
# # unique( work.data[TRIP_ID == "2013.7930", .(TRIP_ID, AGENCY_GEAR_CODE, ADP, REPORT_ID)])
# unique(work.data[TRIP_ID %in% a,  .(TRIP_ID, AGENCY_GEAR_CODE, ADP, REPORT_ID)])[, table(ADP)]  
# # A bunch of trips 2013-2016 are missing data - is this because I can't get DAYS for some of those trips?


#===============#
## Functions ----
#===============#

source("analyses/allocation_evaluation/functions.R")


#======================================================================================================================#
# Stratification -------------------------------------------------------------------------------------------------------
#======================================================================================================================#

# Will will test several alternative stratification schemes:
# -  Status quo
# -  Split FMP by BSAI and GOA for all strata
# -  Split FMP by BSAI and GOA for observer-strata only
# -  Combine fixed-gear strata into pooled fixed gear strata (i.e., OB_FIXED and EM_FIXED)
# -  Combine fixed-gear strata into pooled fixed gear strata and split by BSAI and GOA
# TODO -  Create separate mixed-gear strata separate from HAL and POT
# TODO -  Create separate mixed-gear strata separate from HAL and POT and split by BSAI and GOA

#==================#
## Define Boxes ----
#==================#

# Continue to use 200km spatial hex cells and 1-week temporal definition for boxes

### Current ----
# Box definition without stratifying by FMP
system.time(box_sq <- define_boxes(
  val_2018_2022_dt, c(2e5, 2e5), time = c("week", 1, "TRIP_TARGET_DATE", "LANDING_DATE"),
  year_col = "ADP", stratum_cols = "STRATA", dmn_cols = c("BSAI_GOA", "GEAR"), geom = T))

### BSAI vs GOA ----
# Box definition with FMP stratified, split by BSAI and GOA
system.time(box_bsai_goa <- define_boxes(
  val_2018_2022_dt, c(2e5, 2e5), time = c("week", 1, "TRIP_TARGET_DATE", "LANDING_DATE"),
  year_col = "ADP", stratum_cols = c("STRATA", "BSAI_GOA"), dmn_cols = c("GEAR"), geom = T ))

### BSAI vs GOA for observer strata ----
# Box definition with FMP stratified, split by BSAI and GOA for observer strata only
val_bsai_goa_ob_only <- copy(val_2018_2022_dt)
val_bsai_goa_ob_only[, FMP := ifelse(POOL == "OB", BSAI_GOA, "AK")]
system.time(box_bsai_goa_ob_only <- define_boxes(
  val_bsai_goa_ob_only, c(2e5, 2e5), time = c("week", 1, "TRIP_TARGET_DATE", "LANDING_DATE"),
  year_col = "ADP", stratum_cols = c("STRATA", "FMP"), dmn_cols = c("BSAI_GOA", "GEAR"), geom = T ))

### Combine HAL and POT into gear into fixed-gear strata ----
# Box definition with fixed-gear strata
val_fixed <- copy(val_2018_2022_dt)
val_fixed[STRATA %like% "HAL|POT", STRATA := paste0(POOL, "_", "FIXED")]
system.time(box_fixed <- define_boxes(
  val_fixed, c(2e5, 2e5), time = c("week", 1, "TRIP_TARGET_DATE", "LANDING_DATE"),
  year_col = "ADP", stratum_cols = c("STRATA"), dmn_cols = c("BSAI_GOA", "GEAR"), geom = T ))

# Same thing, but make neighboring gear-specific
system.time(box_fixed_gs <- define_boxes_gs(
  val_fixed, c(2e5, 2e5), time = c("week", 1, "TRIP_TARGET_DATE", "LANDING_DATE"),
  year_col = "ADP", stratum_cols = c("STRATA"), ps_cols = "GEAR", dmn_cols = c("BSAI_GOA", "GEAR"), geom = T))

### Fixed gear strata split by BSAI and GOA ----
# Box definition with fixed-gear strata and FMP stratified by BSAI and GOA
system.time(box_fixed_bsai_goa <- define_boxes(
  val_fixed, c(2e5, 2e5), time = c("week", 1, "TRIP_TARGET_DATE", "LANDING_DATE"),
  year_col = "ADP", stratum_cols = c("STRATA", "BSAI_GOA"), dmn_cols = c("GEAR"), geom = T ))

# Same thing, but make neighboring gear-specific
system.time(box_fixed_bsai_goa_gs <- define_boxes_gs(
  val_fixed, c(2e5, 2e5), time = c("week", 1, "TRIP_TARGET_DATE", "LANDING_DATE"),
  year_col = "ADP", stratum_cols = c("STRATA", "BSAI_GOA"), ps_cols = "GEAR", dmn_cols = c("GEAR"), geom = T))

### Place all mixed-gear trips into a separate stratum
val_mixed <- copy(val_2018_2022_dt)
val_mixed[, STRATA := ifelse(STRATA != "ZERO" & any(GEAR == "HAL") & any(GEAR == "POT"), paste0(POOL, "_MIXED"), STRATA), by = .(TRIP_ID)]
system.time(box_mixed <- define_boxes(
  val_mixed, c(2e5, 2e5), time = c("week", 1, "TRIP_TARGET_DATE", "LANDING_DATE"),
  year_col = "ADP", stratum_cols = c("STRATA"), dmn_cols = c("BSAI_GOA", "GEAR"), geom = T ))

### Place all mixed-gear trips into a separate stratum and split by BSAI and GOA
system.time(box_mixed_bsai_goa <- define_boxes(
  val_mixed, c(2e5, 2e5), time = c("week", 1, "TRIP_TARGET_DATE", "LANDING_DATE"),
  year_col = "ADP", stratum_cols = c("STRATA", "BSAI_GOA"), dmn_cols = c("GEAR"), geom = T ))

#======================================================================================================================#
# Allocation -----------------------------------------------------------------------------------------------------------
#======================================================================================================================#

# We also have several different allocation methods to test.
# -  15% minimum + optimization for observer pool only, 30% allocation to fixed-gear strata (Status quo allocation)
# -  15% minimum + optimization for ALL strata (including all EM strata)
# -  Equal rates
# -  Proximity
#    -  For the mixed-gear strata, additionally perform with neighboring as gear-specific
# -  Cost-weighted boxes
#    -  For the mixed-gear strata, additionally perform with neighboring as gear-specific
# Each of these allocation methods will be tested with our array of stratification schemes!

# Prepare stratus quo stratification data set for equal rates and min_plus_opt
allo_lst <- update_strata(pc_effort_dt, trips_melt, stratum_cols = c("STRATA"), focus_years = 2018:2022)
allo_lst$effort[, CPD := trip_cost_dt[allo_lst$effort, CPD, on =  .(ADP, STRATA)]]

#=================#
## Equal Rates ----
#=================#

# Allocate for equal rates 
allo_er <- allo_equal(allo_lst$effort[STRATA != "ZERO"], budget = 4.5e6)   # Cannot afford 15% across the board in 2018 or 2022

#===============#
## Min + Opt ----
#===============#

### Current stratification ----

#### Status Quo (with EM carve-off) ----

allo_sq_mpo <- allo_min_plus_opt(allo_lst, em_carve_off = T, conf = 0.95, MIN_RATE = 0.15, budget = 4.5e6)
allo_sq_mpo[, .(ADP, STRATA, STRATA_N, CONF, CONF_RATE, MON_RATE, OPT_N)]

#### For all strata (no EM carve-off) ----

# Allocate for min plus opt to all strata (no EM pool carve-off)
allo_mpo <- allo_min_plus_opt(allo_lst, em_carve_off = F, conf = 0.95, MIN_RATE = 0.15, budget = 4.5e6)
# Still can't afford any optimized days in most years (aside from low-effort 2020)
allo_mpo[, .(ADP, STRATA, STRATA_N, CONF, CONF_RATE, MON_RATE, OPT_N)]

### Split by BSAI vs GOA ----

allo_bsai_goa_lst <- update_strata(pc_effort_dt, trips_melt, stratum_cols = c("STRATA", "BSAI_GOA"), focus_years = 2018:2022)

# For costs, at least for now, assume no difference in average cost per trip between FMPs
trip_cost_dt_bsai_goa <- copy(trip_cost_dt)
bsai_goa_dt <- data.table(BSAI_GOA = c("BSAI", "GOA"))
bsai_goa_dt <- bsai_goa_dt[, as.list(unique(trip_cost_dt_bsai_goa[, .(STRATA)])), by = bsai_goa_dt]
trip_cost_dt_bsai_goa <- bsai_goa_dt[trip_cost_dt, on = .(STRATA), allow.cartesian = T]
trip_cost_dt_bsai_goa[, STRATA := paste0(STRATA, "-", BSAI_GOA)]
allo_bsai_goa_lst$effort[, CPD := trip_cost_dt_bsai_goa[allo_bsai_goa_lst$effort, CPD, on = .(ADP, STRATA)]]

#### BSAI vs GOA : Status Quo ----
allo_sq_mpo_bsai_goa <- allo_min_plus_opt(allo_bsai_goa_lst, em_carve_off = T, conf = 0.95, budget = 4.5e6)

#### BSAI vs GOA : For all strata ----
allo_mpo_bsai_goa <- allo_min_plus_opt(allo_bsai_goa_lst, em_carve_off = F, conf = 0.95, budget = 4.5e6)

#### BSAI vs GOA : With 50% Confidence Level (old status quo) ----
# With more strata, the hurdle overall becomes harder to achieve because all strata are smaller
# If we were to ignore the confidence level, what would we get?
allo_mpo_ob_50 <- allo_min_plus_opt(allo_bsai_goa_lst, em_carve_off = F, conf = 0.5, budget = 4.5e6)


# Split by BS vs AI vs GOA #
# NOTE This stratification probably isn't a good idea, and breaks with min_plus_opt anyway because of strata with
# only 1 trip (we'd have to cherry pick which strata are split!)
if(F) {
  # Do the same but split BS vs AI vs GOA
  allo_bs_ai_goa_lst <- update_strata(pc_effort_dt, trips_melt, stratum_cols = c("STRATA", "BS_AI_GOA"), focus_years = 2018:2022)
  # For costs, at least for now, assume no difference in average cost per trip between FMPs
  trip_cost_dt_bs_ai_goa <- copy(trip_cost_dt)
  bs_ai_goa_dt <- data.table(BS_AI_GOA = c("BS", "AI", "GOA"))
  bs_ai_goa_dt <- bs_ai_goa_dt[, as.list(unique(trip_cost_dt_bs_ai_goa[, .(STRATA)])), by = bs_ai_goa_dt]
  trip_cost_dt_bs_ai_goa <- bs_ai_goa_dt[trip_cost_dt, on = .(STRATA), allow.cartesian = T]
  trip_cost_dt_bs_ai_goa[, STRATA := paste0(STRATA, "-", BS_AI_GOA)]
  allo_bs_ai_goa_lst$effort[, CPD := trip_cost_dt_bs_ai_goa[allo_bs_ai_goa_dt$effort, CPD, on = .(ADP, STRATA)]]
  
  # With EM Carve Off #
  # Note - this takes a long time because there are so many strata of varying size - guessing the afforded confidence is hard.
  allo_sq_mpo_bs_ai_goa <- allo_min_plus_opt(allo_bs_ai_goa_lst, em_carve_off = T, conf = 0.95, budget = 4.5e6)
  
  # Without EM Carve Off 
  # This takes longer because I have so many strata and finding the maximized confidence level is harder to guess
  # This breaks because at least one stratum has only 1 trip (calculating variance is impossible)
  allo_bs_ai_goa_lst$effort # We have a few 1-trip strata
  allo_mpo_bs_ai_goa <- allo_min_plus_opt(allo_bs_ai_goa_lst, em_carve_off = F, conf = 0.95, budget = 4.5e6)
}

#=================#
### Fixed Gear ----
#=================#

pc_effort_fixed <- copy(pc_effort_dt)
pc_effort_fixed[STRATA %like% "HAL|POT", STRATA := paste0(POOL, "_", "FIXED")]
allo_fixed_lst <- update_strata(pc_effort_fixed, trips_melt, stratum_cols = c("STRATA"), focus_years = 2018:2022)

# Recalculate ADP x stratum trip_cost table
trip_cost_dt_fixed <- unique(pc_effort_fixed[ADP %in% 2018:2022, .(ADP, STRATA, TRIP_ID, DAYS)])[, .(MEAN_TRIP_DAYS = mean(DAYS)), keyby = .(ADP, STRATA)]
# Merge in day costs
trip_cost_dt_fixed[, CPD := fcase(
  STRATA == "EM_TRW", trwem_cpd,
  STRATA %in% c("EM_FIXED"), fgem_cpd,
  STRATA %like% c("OB"), ob_cpd)]
# Calculate cost per trip
trip_cost_dt_fixed[, CPT := MEAN_TRIP_DAYS * CPD]
trip_cost_dt_fixed[STRATA == "ZERO", ':=' (CPD = 0, CPT = 0)]
# Merge in to effort dt
allo_fixed_lst$effort[, CPD := trip_cost_dt_fixed[allo_fixed_lst$effort, CPD, on = .(ADP, STRATA)]]

#### Fixed Gear : Status Quo ----
allo_sq_mpo_fixed <- allo_min_plus_opt(allo_fixed_lst, em_carve_off = T, conf = 0.95, budget = 4.5e6)

#### Fixed Gear : For all strata ----
allo_mpo_fixed <- allo_min_plus_opt(allo_fixed_lst, em_carve_off = F, conf = 0.95, budget = 4.5e6)

#===============================#
### Fixed Gear + BSAI vs GOA ----
#===============================#

pc_effort_fixed_bsai_goa <- copy(pc_effort_fixed)
pc_effort_fixed_bsai_goa[, STRATA := paste0(STRATA, "-", BSAI_GOA)]
allo_fixed_bsai_goa_lst <- update_strata(pc_effort_fixed_bsai_goa, trips_melt, stratum_cols = c("STRATA"), focus_years = 2018:2022)

# Create new trip_cost table (assuming costs are the sam between BSAI and GOA)
bsai_goa_dt <- data.table(BSAI_GOA = c("BSAI", "GOA"))
bsai_goa_dt <- bsai_goa_dt[, as.list(unique(trip_cost_dt_fixed[, .(STRATA)])), by = bsai_goa_dt]
trip_cost_dt_fixed_bsai_goa <- bsai_goa_dt[trip_cost_dt_fixed, on = .(STRATA), allow.cartesian = T]
trip_cost_dt_fixed_bsai_goa[, STRATA := paste0(STRATA, "-", BSAI_GOA)]
allo_fixed_bsai_goa_lst$effort[, CPD := trip_cost_dt_fixed_bsai_goa[allo_fixed_bsai_goa_lst$effort, CPD, on = .(ADP, STRATA)]]

#### Fixed Gear + BSAI vs GOA : Status Quo ----
allo_sq_mpo_fixed_bsai_goa <- allo_min_plus_opt(allo_fixed_bsai_goa_lst, em_carve_off = T, conf = 0.95, budget = 4.5e6)

#### Fixed Gear + BSAI vs GOA : For all strata ----
allo_mpo_fixed_bsai_goa <- allo_min_plus_opt(allo_fixed_bsai_goa_lst, em_carve_off = F, conf = 0.95, budget = 4.5e6)

#=========================#
## Cost-Weighted Boxes ----
#=========================#

#### Current stratification ----

cwb_prop <- calculate_cwb_Ph(box_sq, sample_rate_vec)
cwb_rates <- allo_cwb_loop(cwb_prop, trip_cost_dt, budget = 4.5e6)
cwb_rates$rates

#### BSAI vs GOA ----
cwb_prop_bsai_goa <- calculate_cwb_Ph(box_bsai_goa, sample_rate_vec)
trip_cost_dt_bsai_goa_cwb <- copy(trip_cost_dt_bsai_goa)
trip_cost_dt_bsai_goa_cwb[, STRATA := gsub("[-].*$", "", STRATA)]  # Strip out the FMPs
cwb_bsai_goa_rates <- allo_cwb_loop(cwb_prop_bsai_goa, trip_cost_dt_bsai_goa_cwb, budget = 4.5e6)
cwb_bsai_goa_rates$rates

#### Fixed Gear ---- 
cwb_prop_fixed <- calculate_cwb_Ph(box_fixed, sample_rate_vec)
cwb_fixed_rates <- allo_cwb_loop(cwb_prop_fixed, trip_cost_dt_fixed, budget = 4.5e6)
cwb_fixed_rates$rates

ggplot(cwb_prop_fixed$Ph_dt, aes(x = SAMPLE_RATE, y = Ph, color = STRATA)) + facet_grid(ADP ~ .) + geom_line()
# Ph is the expected proportion of boxes that will not be sampled given a stratum's sampling rate. 
# As sample rate increases, Ph decreases. In 'NP/c_h', we have it in the numerator because larger numbers 
# (a higher proportion of expected gaps) increase the value and therefore the amount we allocate to that stratum. 
# 'C_h' is on the bottom because if a stratum is cheaper to monitor, it increases the value and tells us to allocate more to that stratum.

#### Fixed Gear (gear-specific) ---- 
# TODO - Need to make a gear-specific version of calcualte_cwb_Ph!

#### Fixed Gear + BSAI vs GOA ---- 
cwb_prop_fixed_bsai_goa <- calculate_cwb_Ph(box_fixed_bsai_goa, sample_rate_vec)
trip_cost_dt_fixed_bsai_goa_cwb <- copy(trip_cost_dt_fixed_bsai_goa)
trip_cost_dt_fixed_bsai_goa_cwb[, STRATA := gsub("[-].*$", "", STRATA)]  # Strip out the FMPs
cwb_fixed_rates_bsai_goa <- allo_cwb_loop(cwb_prop_fixed_bsai_goa, trip_cost_dt_fixed_bsai_goa_cwb, budget = 4.5e6)
cwb_fixed_rates_bsai_goa$rates

#### Combined Fixed Gear + BSAI vs GOA (gear-specific) ---- 
# TODO
box_fixed_bsai_goa_gs

#===============#
## Proximity ----
#===============#

#### Current stratification ----
prox_sq_insp <- calculate_interspersion(box_sq, sample_rate_vec, omit_strata = "ZERO")
prox_sq_index <- calculate_index(prox_sq_insp, trip_cost_dt)
prox_sq_rates <- prox_rates_from_budget(prox_sq_index, 4.5e6)

#### BSAI vs GOA ----
prox_bsai_goa_insp <- calculate_interspersion(box_bsai_goa, sample_rate_vec, omit_strata = "ZERO")
prox_bsai_goa_index <- calculate_index(prox_bsai_goa_insp, trip_cost_dt_bsai_goa_cwb)                  # TODO rename this something common to cwb and prox
prox_bsai_goa_rates <- prox_rates_from_budget(prox_bsai_goa_index, 4.5e6)

#### Fixed Gear ---- 
prox_fixed_insp <- calculate_interspersion(box_fixed, sample_rate_vec, omit_strata = "ZERO")
prox_fixed_index <- calculate_index(prox_fixed_insp, trip_cost_dt_fixed)
prox_fixed_rates <- prox_rates_from_budget(prox_fixed_index, 4.5e6)

#### Fixed Gear (gear-specific) ---- 
prox_fixed_gs_insp <- calculate_interspersion_gs(box_fixed_gs, sample_rate_vec, omit_strata = "ZERO")
prox_fixed_gs_index <- calculate_index(prox_fixed_gs_insp, trip_cost_dt_fixed)
prox_fixed_gs_rates <- prox_rates_from_budget(prox_fixed_gs_index, 4.5e6)

# Rates are similar, but that is probably largely driven by the huge difference in stratum size. Notice that
# just a 0.2% difference in rates resulted in almost a 0.05 change in ISPN because of the gear-specificity.

#### Fixed Gear + BSAI vs GOA ---- 
prox_fixed_bsai_goa_insp <- calculate_interspersion(box_fixed_bsai_goa, sample_rate_vec, omit_strata = "ZERO")
prox_fixed_bsai_goa_index <- calculate_index(prox_fixed_bsai_goa_insp, trip_cost_dt_fixed_bsai_goa_cwb)        # FIXME rename this to something more general
prox_fixed_bsai_goa_rates <- prox_rates_from_budget(prox_fixed_bsai_goa_index, 4.5e6)

#### Fixed Gear + BSAI vs GOA (gear-specific) ----
prox_fixed_bsai_goa_gs_insp <- calculate_interspersion_gs(box_fixed_bsai_goa_gs, sample_rate_vec, omit_strata = "ZERO")
prox_fixed_bsai_goa_gs_index <- calculate_index(prox_fixed_bsai_goa_gs_insp, trip_cost_dt_fixed_bsai_goa_cwb)        # FIXME rename this to something more general
prox_fixed_bsai_goa_gs_rates <- prox_rates_from_budget(prox_fixed_bsai_goa_gs_index, 4.5e6)

#### Mixed Gear ---- 
# TODO
# TODO Does using the gear-specific version change much? I would guess that it would be virtually the same, the only
# with slightly less overlap for trips that didn't use both gear types in all boxes they fished in.
box_mixed_insp <- calculate_interspersion(box_mixed, sample_rate_vec, omit_strata = "ZERO")
# TODO need to make trip_cost_dt_mixed, using CPD * average trip duration

#==================#
# Compile Rates ---- 
#==================#

er_cols <- setdiff(colnames(allo_er), c("MIN_RATE", "MIN_N", "MIN_D", "TOT_MIN_D", "OPT_N"))
mpo_cols <- setdiff(c(colnames(allo_er), "CONF", "CONF_RATE", "W_hopt"), c("MIN_RATE", "MIN_N", "MIN_D", "TOT_MIN_D"))

rates_lst <- list(
  
  ## Equal Rates ----
  
  EQUAL = list(EQUAL = allo_er[, ..er_cols]),
  
  ## Min + Opt (Status Quo) ---
  # (with 30% FG_EM and 1/3 TRW_EM
  MPO_SQ = list(
    sq = allo_sq_mpo[, ..mpo_cols],
    bsai_goa = allo_sq_mpo_bsai_goa[, ..mpo_cols],
    fixed = allo_sq_mpo_fixed[, ..mpo_cols],
    fixed_bsai_goa = allo_sq_mpo_fixed_bsai_goa[, ..mpo_cols]
  ),
  
  ## Min + Opt ----
  MPO = list(
    sq = allo_mpo[, ..mpo_cols],
    bsai_goa = allo_mpo_bsai_goa[, ..mpo_cols],
    fixed = allo_mpo_fixed[, ..mpo_cols],
    fixed_bsai_goa = allo_mpo_fixed_bsai_goa[, ..mpo_cols]
  ),
  
  ## CWB ----
  # fh is the selection rate allocated, SAMPLE_RATE is the sample rate that is assumed beforehand to determine Ph, and should be very close to fh
  CWB = list(
    sq = cwb_rates$rates,
    bsai_goa = cwb_bsai_goa_rates$rates,
    fixed = cwb_fixed_rates$rates,
    fixed_bsai_goa = cwb_fixed_rates_bsai_goa$rates
  ),
  #  (still need to do this with gear-specific interspersion)
  #  (still need to do this with mixed-gear stratification
  
  ## Proximity ----
  PROX = list(
    sq = prox_sq_rates,
    bsai_goa  = prox_bsai_goa_rates,
    fixed = prox_fixed_rates,
    fixed_gs = prox_fixed_gs_rates,
    fixed_bsai_goa = prox_fixed_bsai_goa_rates,
    fixed_bsai_goa_gs = prox_fixed_bsai_goa_gs_rates
  )
  #  (still need to do this with mixed-gear stratification
  
)

save(rates_lst, file = "analyses/stratification/rates_test.rdata")


#==========================#
# Testing of Evaluation ----
#==========================#

target_budget <- data.table(ADP = 2022L, INDEX_COST = 4.5e6)
box_fixed_index$rates[, .SD[target_budget, on = .(ADP, INDEX_COST), roll = "nearest"], by = .(STRATA)]
box_fixed_gs_index$rates[, .SD[target_budget, on = .(ADP, INDEX_COST), roll = "nearest"], by = .(STRATA)]
box_fixed_bsai_goa_gs_index$rates[, .SD[target_budget, on = .(ADP, INDEX_COST), roll = "nearest"], by = .(STRATA, BSAI_GOA)]
# Only 8% in all if fixed-gear GOA, but all other strata have pretty high rates. How this pans out allocation-wise will be interesting
box_fixed_bsai_goa_gs_index$rates[, .SD[target_budget, on = .(ADP, INDEX_COST), roll = "nearest"], by = .(STRATA, BSAI_GOA)][STRATA %like% "EM_FIXED", sum(n * CPT)]
# It allocates around $640K to fixed-gear EM, opposed to $1M under status quo

donor_ob_fixed_bsai_goa <- data.table(STRATA = rep(c("OB_FIXED", "OB_TRW"), each = 2), BSAI_GOA = rep(c("BSAI", "GOA"), times = 2))
target_budget_all_years <- data.table(ADP = 2018:2022, INDEX_COST = 4.5e6)


box_fixed_bsai_goa$dmn$strata_dt  #UMM THIS IS NOT WHAT I WANTED
allo_prox_fixed_bsai_goa_acceptor_donor_lst <- c(
  rep(list(4:5), times = 2),                # 1-2: EM_HAL and EM_POT 
  list(3),                                  # 3: EM_TRW
  rep(list(4:5), times = 2),                # 4-5: OB_Mixed
  rep(list(6:7), times = 2),                # 6-7: OB_TRW                            
  rep(list(4:5), times = 2)                 # 8-9:  ZERO           
)

# Evaluation for FG_combed + BSAI_GOA (NOT gear-specific)
allo_prox_fixed_bsai_goa <- calculate_dmn_interspersion3(
  box_fixed_bsai_goa,
  selection_rates = box_fixed_bsai_goa_index$rates[, .SD[target_budget_all_years, on = .(ADP, INDEX_COST), roll = "nearest"], by = .(STRATA, BSAI_GOA)],
  acceptor_donor_lst = allo_prox_fixed_bsai_goa_acceptor_donor_lst
)
allo_prox_fixed_bsai_smry  <- dmn_interspersion_smry(allo_prox_fixed_bsai_goa)
allo_prox_fixed_bsai_plots <- dmn_interspersion_plot(allo_prox_fixed_bsai_goa)  # FIXME make the plots ordered by year_col
allo_prox_fixed_bsai_smry$BSAI_GOA

# Evaluation for FG_combed + BSAI_GOA (gear-specific)
allo_prox_fixed_bsai_goa_gs <- calculate_dmn_interspersion3(
  box_fixed_bsai_goa_gs,
  selection_rates = box_fixed_bsai_goa_gs_index$rates[, .SD[target_budget_all_years, on = .(ADP, INDEX_COST), roll = "nearest"], by = .(STRATA, BSAI_GOA)],
  acceptor_donor_lst = allo_prox_fixed_bsai_goa_acceptor_donor_lst
)
allo_prox_fixed_bsai_gs_smry  <- dmn_interspersion_smry(allo_prox_fixed_bsai_goa_gs)
allo_prox_fixed_bsai_gs_plots <- dmn_interspersion_plot(allo_prox_fixedd_bsai_goa_gs)  # FIXME make the plots ordered by year_col
allo_prox_fixed_bsai_gs_smry$BSAI_GOA

a <- rbind(
  cbind(Method = "combined",      allo_prox_fixed_bsai_smry$BSAI_GOA),
  cbind(Method = "gear-specific", allo_prox_fixed_bsai_gs_smry$BSAI_GOA)
)
a[, sum(POOL_DMN_INTERSPERSION), keyby = .(ADP, Method)]
ggplot(a, aes(x = BSAI_GOA, y = POOL_DMN_INTERSPERSION, fill = Method)) + facet_grid(ADP ~ POOL + GEAR) + geom_col(position = position_dodge())

a1 <- as.data.table(cbind(
  combined = allo_prox_fixed_bsai_smry$BSAI_GOA$POOL_DMN_INTERSPERSION,
  gs = allo_prox_fixed_bsai_gs_smry$BSAI_GOA$POOL_DMN_INTERSPERSION
))
a1[, DIFF := gs - combined]
sum(a1$DIFF)  # by BSAI, gear-specific did better
ggplot(a1, aes(x = DIFF)) + geom_histogram()
# Also, overall, gear-specific did better (as should be expected since the allocation more closely matches the evaluation)
sum(allo_prox_fixed_bsai_gs_smry$OVERALL$POOL_DMN_INTERSPERSION) - sum(allo_prox_fixed_bsai_smry$OVERALL$POOL_DMN_INTERSPERSION)


# Difference of having EM strata set at status quo rates or not, with current stratification, compared to equal rates
allo_er[ADP==2022 & STRATA %like% "OB", sum(MON_N)]
allo_sq_mpo[ADP==2022 & STRATA %like% "OB", sum(MON_N)]
allo_er[ADP==2022 & STRATA %in% c("EM_HAL", "EM_POT"), sum(CPD * STRATA_N * MON_RATE * TRP_DUR)]
allo_sq_mpo[ADP==2022 & STRATA %in% c("EM_HAL", "EM_POT"), sum(CPD * STRATA_N * MON_RATE * TRP_DUR)]
