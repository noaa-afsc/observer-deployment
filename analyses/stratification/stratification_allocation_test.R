# Author: Geoff Mayhew
# Here, we will see the effects that alternate stratification schemes have on our allocation methods.
# In addition, we will have to tweak our current allocation methods to be compatible with new stratification 
# schemes.

# TODO list

# [ ] how to handle CV scaling with fixed-gear stratification? What is CV scaling of entire stratum vs two separate post-strata?
#======================================================================================================================#
# Preparation ----------------------------------------------------------------------------------------------------------
#======================================================================================================================#

#===================#
## Load Packages ----
#===================#

library(data.table)         # Data wrangling
library(ggplot2)            # Plotting
library(grid)               # For unit.pmax  to get widths of grobs so that plots have matching dimensions
library(gridExtra)          # For arrangeGrob to combine plots
library(sf)                 # Spatial analyses
library(flextable)          # For print-ready tables
library(dplyr)              # For piping and handling sf objects


#=============================#
## Load data and data prep ----
#=============================#

# Fishing effort data from 2018 to 2022
# `spatiotemporal_boxes.rdata' is generated by /analyses/spatiotemporal_boxes/data_prep.R
load("analyses/allocation_evaluation/allocation_evaluation.Rdata")   # loads pc_effort_dt and trips_melt

# Load the ADFG statistical area shapefile. '../' is needed for Rmarkdown to climb into parent folders.
stat_area_sf <- st_read(
  dsn = "source_data/ADFG_Stat_Area_shapefile/PVG_Statewide_2001_Present_GCS_WGS1984.shp", quiet = T) %>%
  select(STAT_AREA) %>%
  st_transform(crs = 3467)

# Load the Alaska map sf objects
load("source_data/ak_shp.rdata")      # shp_land, shp_nmfs, and shp_centroids added to global

sample_rate_vec <- seq(from = 0.005, to = 0.95, by = 0.0001) 

#===============================#
## Prepare trips_melt object ----
#===============================#

# trips_melt has metrics and trip duration for all trips >= 2015. . 
# Add ADP year, STRATA, and DAYS of each TRIP_ID to trips_melt
trips_melt_add_data <- unique(pc_effort_dt[STRATA != "ZERO", .(ADP, TRIP_ID, STRATA, DAYS)])
trips_melt <- trips_melt_add_data[trips_melt, on = .(TRIP_ID)]
setcolorder(trips_melt, c("ADP", "STRATA", "TRIP_ID", "DAYS", "Metric", "Value"))
setkey(trips_melt, ADP, STRATA, TRIP_ID, DAYS, Metric, Value)
# Error-check
if(nrow(trips_melt[, .N, by = .(TRIP_ID)][N != uniqueN(trips_melt$Metric)])) stop("At least one trip has number of metrics != 3!")
# Remove records missing data
trips_melt <- trips_melt[!is.na(ADP)]

#===============#
## Functions ----
#===============#

source("analyses/allocation_evaluation/functions.R")

  
#================#
## Trip Costs ----
#================#

# Specific to monitoring method. Use average values from the 2023 Final ADP for now.
ob_cpd <- 4896623 / 3094         # $1582.619/day
fgem_cpd <- 1e6 / (1040+735)     # $ 563.380/day
trwem_cpd <- 600                 # $600/day according to JF estimates used in set_budget.R in 2022 Final ADP repo


#======================================================================================================================#
# Designs --------------------------------------------------------------------------------------------------------------
#======================================================================================================================#

# Will will test several alternative stratification schemes:
# -  Status quo
# -  Split FMP by BSAI and GOA for all strata
# -  Split FMP by BSAI and GOA for observer-strata only
# -  Combine fixed-gear strata into pooled fixed gear strata (i.e., OB_FIXED and EM_FIXED)
# -  Combine fixed-gear strata into pooled fixed gear strata and split by BSAI and GOA
# -  Create separate mixed-gear strata separate from HAL and POT
# -  Create separate mixed-gear strata separate from HAL and POT and split by BSAI and GOA

# Continue to use 200km spatial hex cells and 1-week temporal definition for boxes
# Create new data objects with redefined stratifications and costs

#============================#
## Current Stratification ----
#============================#

val_2018_2022_dt <- pc_effort_dt[ADP %in% 2018:2022]
dcast(val_2018_2022_dt[, .(N = uniqueN(TRIP_ID)), keyby = .(ADP, STRATA)],STRATA ~ ADP, value.var = "N")

# Box definition without stratifying by FMP
system.time(box_sq <- define_boxes(
  val_2018_2022_dt, c(2e5, 2e5), time = c("week", 1, "TRIP_TARGET_DATE", "LANDING_DATE"),
  year_col = "ADP", stratum_cols = "STRATA", dmn_cols = c("BSAI_GOA", "GEAR"), geom = T))
# Estimate costs per trip
trip_cost_dt <- unique(val_2018_2022_dt[, .(ADP, STRATA, TRIP_ID, DAYS)])[, .(MEAN_TRIP_DAYS = mean(DAYS)), keyby = .(ADP, STRATA)]
trip_cost_dt[
][, CPD := fcase(
  STRATA == "EM_TRW", trwem_cpd,
  STRATA %in% c("EM_POT", "EM_HAL"), fgem_cpd,
  STRATA %in% c("OB_HAL", "OB_POT", "OB_TRW"), ob_cpd)
][, CPT := MEAN_TRIP_DAYS * CPD
][STRATA == "ZERO", ':=' (CPD = 0, CPT = 0)]
# Prepare stratus quo stratification data set for equal rates and min_plus_opt. Merge in day costs
allo_lst <- update_strata(pc_effort_dt, trips_melt, stratum_cols = c("STRATA"), focus_years = 2018:2022)
allo_lst$effort[, CPD := trip_cost_dt[allo_lst$effort, CPD, on =  .(ADP, STRATA)]]

### Equal Rates ----

equal_rates <- allo_equal(allo_lst$effort[STRATA != "ZERO"], budget = 4.5e6)   # Cannot afford 15% across the board in 2018 or 2022

### Min+Opt ----

# Status quo with EM carve-off
mpo_sq_rates <- allo_min_plus_opt(allo_lst, em_carve_off = T, conf = 0.95, MIN_RATE = 0.15, budget = 4.5e6)
# Allocate for min plus opt to all strata (no EM pool carve-off)
mpo_rates <- allo_min_plus_opt(allo_lst, em_carve_off = F, conf = 0.95, MIN_RATE = 0.15, budget = 4.5e6)
# With 50% Confidence Level (old status quo) 
mpo_50_rates <- allo_min_plus_opt(allo_lst, em_carve_off = F, conf = 0.5, budget = 4.5e6)

### CWB ----

cwb_prop <- calculate_cwb_Ph(box_sq, sample_rate_vec)
cwb_rates <- allo_cwb_loop(cwb_prop, trip_cost_dt, budget = 4.5e6)

### Proximity ----

prox_insp <- calculate_interspersion(box_sq, sample_rate_vec, omit_strata = "ZERO")
prox_index <- calculate_index(prox_insp, trip_cost_dt)
prox_rates <- prox_rates_from_budget(prox_index, 4.5e6)


#=========#
## FMP ----
#=========#

dcast(val_2018_2022_dt[, .(N = uniqueN(TRIP_ID)), keyby = .(ADP, STRATA, BSAI_GOA)], STRATA + BSAI_GOA ~ ADP, value.var = "N")
# Box definition with FMP stratified, split by BSAI and GOA
system.time(box_fmp <- define_boxes(
  val_2018_2022_dt, c(2e5, 2e5), time = c("week", 1, "TRIP_TARGET_DATE", "LANDING_DATE"),
  year_col = "ADP", stratum_cols = c("STRATA", "BSAI_GOA"), dmn_cols = c("GEAR"), geom = T ))
# Estimate costs per trip
trip_cost_fmp_dt <- unique(val_2018_2022_dt[, .(ADP, STRATA, BSAI_GOA, TRIP_ID, DAYS)])[, .(MEAN_TRIP_DAYS = mean(DAYS)), keyby = .(ADP, STRATA, BSAI_GOA)]
trip_cost_fmp_dt[
][, CPD := fcase(
  STRATA %like% "EM_TRW", trwem_cpd,
  STRATA %like% "EM_POT|EM_HAL", fgem_cpd,
  STRATA %like% "OB_HAL|OB_POT|OB_TRW", ob_cpd)
][, CPT := MEAN_TRIP_DAYS * CPD
][STRATA == "ZERO", ':=' (CPD = 0, CPT = 0)
][, STRATUM_COL := paste0(STRATA, "-", BSAI_GOA)]
# Redefine strata for equal rates and min+opt functions, merge in day costs
allo_fmp_lst <- update_strata(pc_effort_dt, trips_melt, stratum_cols = c("STRATA", "BSAI_GOA"), focus_years = 2018:2022)
allo_fmp_lst$effort[, CPD := trip_cost_fmp_dt[allo_fmp_lst$effort, CPD, on =  c(ADP = "ADP", STRATUM_COL = "STRATA")]]

### Min+Opt ----

# With EM carve-off
mpo_sq_fmp_rates <- allo_min_plus_opt(allo_fmp_lst, em_carve_off = T, conf = 0.95, budget = 4.5e6)
# For all strata (No EM carve-off)
mpo_fmp_rates <- allo_min_plus_opt(allo_fmp_lst, em_carve_off = F, conf = 0.95, budget = 4.5e6)
# With 50% Confidence Level (old status quo) 
# With more strata, the hurdle overall becomes harder to achieve because all strata are smaller
mpo_50_fmp_rates <- allo_min_plus_opt(allo_fmp_lst, em_carve_off = F, conf = 0.5, budget = 4.5e6)

### CWB ----

cwb_fmp_prop <- calculate_cwb_Ph(box_fmp, sample_rate_vec)
cwb_fmp_rates <- allo_cwb_loop(cwb_fmp_prop, trip_cost_fmp_dt, budget = 4.5e6)

### Proximity ----

prox_fmp_insp <- calculate_interspersion(box_fmp, sample_rate_vec, omit_strata = "ZERO")
prox_fmp_index <- calculate_index(prox_fmp_insp, trip_cost_fmp_dt)                
prox_fmp_rates <- prox_rates_from_budget(prox_fmp_index, 4.5e6)

### FMP for observer strata 
# TODO Do I use this anywhere?
# Box definition with FMP stratified, split by BSAI and GOA for observer strata only
# val_bsai_goa_ob_only <- copy(val_2018_2022_dt)
# val_bsai_goa_ob_only[, FMP := ifelse(POOL == "OB", BSAI_GOA, "AK")]
# system.time(box_fmp_ob_only <- define_boxes(
#   val_bsai_goa_ob_only, c(2e5, 2e5), time = c("week", 1, "TRIP_TARGET_DATE", "LANDING_DATE"),
#   year_col = "ADP", stratum_cols = c("STRATA", "FMP"), dmn_cols = c("BSAI_GOA", "GEAR"), geom = T ))


#=============#
## Fixed ----
#=============#

# Combine HAL and POT into gear into fixed-gear strata
pc_effort_fixed <- unique(copy(pc_effort_dt)[STRATA %like% "HAL|POT", STRATA := paste0(POOL, "_", "FIXED")])
val_fixed <- pc_effort_fixed[ADP %in% 2018:2022]
dcast(val_fixed[, .(N = uniqueN(TRIP_ID)), keyby = .(ADP, STRATA)], STRATA ~ ADP, value.var = "N")

# Box definition with fixed-gear strata
system.time(box_fixed <- define_boxes(
  val_fixed, c(2e5, 2e5), time = c("week", 1, "TRIP_TARGET_DATE", "LANDING_DATE"),
  year_col = "ADP", stratum_cols = c("STRATA"), dmn_cols = c("BSAI_GOA", "GEAR"), geom = T ))
# Define boxes again but make neighboring gear-specific for the fixed-gear strata
system.time(box_fixed_gs <- define_boxes_gs(
  val_fixed, c(2e5, 2e5), time = c("week", 1, "TRIP_TARGET_DATE", "LANDING_DATE"),
  year_col = "ADP", stratum_cols = c("STRATA"), ps_cols = "GEAR", dmn_cols = c("BSAI_GOA", "GEAR"), geom = T))
# Estimate costs per trip
trip_cost_fixed_dt <- unique(val_fixed[, .(ADP, STRATA, BSAI_GOA, TRIP_ID, DAYS)])[, .(MEAN_TRIP_DAYS = mean(DAYS)), keyby = .(ADP, STRATA)]
trip_cost_fixed_dt[
][, CPD := fcase(
  STRATA %like% "EM_TRW", trwem_cpd,
  STRATA %like% "EM_FIXED", fgem_cpd,
  STRATA %like% "OB_FIXED|OB_TRW", ob_cpd)
][, CPT := MEAN_TRIP_DAYS * CPD
][STRATA == "ZERO", ':=' (CPD = 0, CPT = 0)]
# Redefine strata for equal rates and min+opt functions, merge in day costs
allo_fixed_lst <- update_strata(pc_effort_fixed, trips_melt, stratum_cols = c("STRATA"), focus_years = 2018:2022)
allo_fixed_lst$effort[, CPD := trip_cost_fixed_dt[allo_fixed_lst$effort, CPD, on = .(ADP, STRATA)]]

### Min+Opt ----

# With EM carve-off
mpo_sq_fixed_rates <- allo_min_plus_opt(allo_fixed_lst, em_carve_off = T, conf = 0.95, budget = 4.5e6)
# For all strata 
mpo_fixed_rates <- allo_min_plus_opt(allo_fixed_lst, em_carve_off = F, conf = 0.95, budget = 4.5e6)

### CWB ----

# Allowing all fixed-gear trips to neighbor
cwb_fixed_prop <- calculate_cwb_Ph(box_fixed, sample_rate_vec)
cwb_fixed_rates <- allo_cwb_loop(cwb_fixed_prop, trip_cost_fixed_dt, budget = 4.5e6)

# Neighboring is gear-specific
cwb_fixed_gs_prop <- calculate_cwb_Ph_gs(box_fixed_gs, sample_rate_vec)
cwb_fixed_gs_rates <- allo_cwb_loop(cwb_fixed_gs_prop, trip_cost_fixed_dt, budget = 4.5e6)

### Proximity ----

# Allowing all fixed-gear trips to neighbor
prox_fixed_insp <- calculate_interspersion(box_fixed, sample_rate_vec, omit_strata = "ZERO")
prox_fixed_index <- calculate_index(prox_fixed_insp, trip_cost_fixed_dt)
prox_fixed_rates <- prox_rates_from_budget(prox_fixed_index, 4.5e6)

# Neighboring is gear-specific
prox_fixed_gs_insp <- calculate_interspersion_gs(box_fixed_gs, sample_rate_vec, omit_strata = "ZERO")
prox_fixed_gs_index <- calculate_index(prox_fixed_gs_insp, trip_cost_fixed_dt)
prox_fixed_gs_rates <- prox_rates_from_budget(prox_fixed_gs_index, 4.5e6)

# Rates are similar, but that is probably largely driven by the huge difference in stratum size. Notice that
# just a 0.2% difference in rates resulted in almost a 0.05 change in ISPN because of the gear-specificity.


#=================#
## Fixed X FMP ----
#=================#

# Fixed gear strata split by BSAI and GOA
dcast(val_fixed[, .(N = uniqueN(TRIP_ID)), keyby = .(ADP, STRATA, BSAI_GOA)], STRATA + BSAI_GOA ~ ADP, value.var = "N")
# Box definition with fixed-gear strata and FMP stratified by BSAI and GOA
system.time(box_fixed_fmp <- define_boxes(
  val_fixed, c(2e5, 2e5), time = c("week", 1, "TRIP_TARGET_DATE", "LANDING_DATE"),
  year_col = "ADP", stratum_cols = c("STRATA", "BSAI_GOA"), dmn_cols = c("GEAR"), geom = T ))
# Same thing, but make neighboring gear-specific
system.time(box_fixed_fmp_gs <- define_boxes_gs(
  val_fixed, c(2e5, 2e5), time = c("week", 1, "TRIP_TARGET_DATE", "LANDING_DATE"),
  year_col = "ADP", stratum_cols = c("STRATA", "BSAI_GOA"), ps_cols = "GEAR", dmn_cols = c("GEAR"), geom = T))
# Estimate costs per trip
trip_cost_fixed_fmp_dt <- unique(val_fixed[, .(ADP, STRATA, BSAI_GOA, TRIP_ID, DAYS)])[, .(MEAN_TRIP_DAYS = mean(DAYS)), keyby = .(ADP, STRATA, BSAI_GOA)]
trip_cost_fixed_fmp_dt[
][, CPD := fcase(
  STRATA %like% "EM_TRW", trwem_cpd,
  STRATA %like% "EM_FIXED", fgem_cpd,
  STRATA %like% "OB_FIXED|OB_TRW", ob_cpd)
][, CPT := MEAN_TRIP_DAYS * CPD
][STRATA == "ZERO", ':=' (CPD = 0, CPT = 0)
][, STRATUM_COL := paste0(STRATA, "-", BSAI_GOA)]
# Redefine strata for equal rates and min+opt functions, merge in day costs
allo_fixed_fmp_lst <- update_strata(pc_effort_fixed, trips_melt, stratum_cols = c("STRATA", "BSAI_GOA"), focus_years = 2018:2022)
allo_fixed_fmp_lst$effort[, CPD := trip_cost_fixed_fmp_dt[allo_fixed_fmp_lst$effort, CPD, on = c(ADP = "ADP", STRATUM_COL = "STRATA")]]

### Min+Opt ----

# With EM carve-off
mpo_sq_fixed_fmp_rates <- allo_min_plus_opt(allo_fixed_fmp_lst, em_carve_off = T, conf = 0.95, budget = 4.5e6)
# For all strata (no EM carve-off)
mpo_fixed_fmp_rates <- allo_min_plus_opt(allo_fixed_fmp_lst, em_carve_off = F, conf = 0.95, budget = 4.5e6)

### CWB ----

# Allowing all fixed-gear trips to neighbor
cwb_fixed_fmp_prop <- calculate_cwb_Ph(box_fixed_fmp, sample_rate_vec)
cwb_fixed_fmp_rates <- allo_cwb_loop(cwb_fixed_fmp_prop, trip_cost_fixed_fmp_dt, budget = 4.5e6)

# Neighboring is gear-specific
cwb_fixed_fmp_gs_prop <- calculate_cwb_Ph_gs(box_fixed_fmp_gs, sample_rate_vec)
cwb_fixed_fmp_gs_rates <- allo_cwb_loop(cwb_fixed_fmp_gs_prop, trip_cost_fixed_fmp_dt, budget = 4.5e6)

### Proximity ----

# Allowing all fixed-gear trips to neighbor
prox_fixed_fmp_insp <- calculate_interspersion(box_fixed_fmp, sample_rate_vec, omit_strata = "ZERO")
prox_fixed_fmp_index <- calculate_index(prox_fixed_fmp_insp, trip_cost_fixed_fmp_dt)
prox_fixed_fmp_rates <- prox_rates_from_budget(prox_fixed_fmp_index, 4.5e6)

# Neighboring is gear-specific
prox_fixed_fmp_gs_insp <- calculate_interspersion_gs(box_fixed_fmp_gs, sample_rate_vec, omit_strata = "ZERO")
prox_fixed_fmp_gs_index <- calculate_index(prox_fixed_fmp_gs_insp, trip_cost_fixed_fmp_dt)
prox_fixed_fmp_gs_rates <- prox_rates_from_budget(prox_fixed_fmp_gs_index, 4.5e6)


#===========#
## Mixed ----
#===========#

# Place all mixed-gear trips into separate strata 
pc_effort_mixed <- unique(copy(pc_effort_dt)[, STRATA := ifelse(STRATA != "ZERO" & any(GEAR == "HAL") & any(GEAR == "POT"), paste0(POOL, "_", "MIXED"), STRATA), by = .(TRIP_ID)])
val_mixed <- pc_effort_mixed[ADP %in% 2018:2022]
dcast(val_mixed[, .(N = uniqueN(TRIP_ID)), keyby = .(ADP, STRATA)], STRATA ~ ADP, value.var = "N", fill = 0)
#   NOTE   mixed-gear useage was very low in 2018/2019, but stratum sizes were significant enough in 2020 onward
# to inform future years
# Box definition with mixed-gear strata
system.time(box_mixed <- define_boxes(
  val_mixed, c(2e5, 2e5), time = c("week", 1, "TRIP_TARGET_DATE", "LANDING_DATE"),
  year_col = "ADP", stratum_cols = c("STRATA"), dmn_cols = c("BSAI_GOA", "GEAR"), geom = T ))
# Estimate costs per trip
trip_cost_mixed_dt <- unique(val_mixed[, .(ADP, STRATA, BSAI_GOA, TRIP_ID, DAYS)])[, .(MEAN_TRIP_DAYS = mean(DAYS)), keyby = .(ADP, STRATA)]
trip_cost_mixed_dt[
][, CPD := fcase(
  STRATA %like% "EM_TRW", trwem_cpd,
  STRATA %like% "EM_POT|EM_HAL|EM_MIXED", fgem_cpd,
  STRATA %like% "OB_POT|OB_HAL|OB_MIXED|OB_TRW", ob_cpd)
][, CPT := MEAN_TRIP_DAYS * CPD
][STRATA == "ZERO", ':=' (CPD = 0, CPT = 0)]
# Redefine strata for equal rates and min+opt functions, merge in day costs
allo_mixed_lst <- update_strata(pc_effort_mixed, trips_melt, stratum_cols = c("STRATA"), focus_years = 2018:2022)
allo_mixed_lst$effort[, CPD := trip_cost_mixed_dt[allo_mixed_lst$effort, CPD, on = .(ADP, STRATA)]]

### Min+Opt ----

# With EM carve-off
mpo_sq_mixed_rates <- allo_min_plus_opt(allo_mixed_lst, em_carve_off = T, conf = 0.95, budget = 4.5e6)
# For all strata (no EM carve-off)
mpo_mixed_rates <- allo_min_plus_opt(allo_mixed_lst, em_carve_off = F, conf = 0.95, budget = 4.5e6)

### CWB ----

# Allowing all fixed-gear trips to neighbor
cwb_mixed_prop <- calculate_cwb_Ph(box_mixed, sample_rate_vec)
cwb_mixed_rates <- allo_cwb_loop(cwb_mixed_prop, trip_cost_mixed_dt, budget = 4.5e6)

### Proximity ----

# Allowing all fixed-gear trips to neighbor
prox_mixed_insp <- calculate_interspersion(box_mixed, sample_rate_vec, omit_strata = "ZERO")
prox_mixed_index <- calculate_index(prox_mixed_insp, trip_cost_mixed_dt)
prox_mixed_rates <- prox_rates_from_budget(prox_mixed_index, 4.5e6)

#=================#
## Mixed X FMP ----
#=================#

dcast(val_mixed[, .(N = uniqueN(TRIP_ID)), keyby = .(ADP, STRATA, BSAI_GOA)], STRATA + BSAI_GOA ~ ADP, value.var = "N", fill = 0)
#     NOTE !!!      No or few BSAI/MIXED trips in the BSAI - cannot reasonably use past fishing to allocate for 2021/2022!
# This stratification doesn't work with min+opt because there are no estimates of prior stratum variance or trip duration
# Yes, we could make the mixed-gear strata span AK-wide instead of being by FMP, but we lose any ability of targeting the BSAI.

# Place all mixed-gear trips into a separate stratum and split by BSAI and GOA
# system.time(box_mixed_bsai_goa <- define_boxes(
#   val_mixed, c(2e5, 2e5), time = c("week", 1, "TRIP_TARGET_DATE", "LANDING_DATE"),
#   year_col = "ADP", stratum_cols = c("STRATA", "BSAI_GOA"), dmn_cols = c("GEAR"), geom = T ))
# # Estimate costs per trip
# trip_cost_mixed_fmp_dt <- unique(val_mixed[, .(ADP, STRATA, BSAI_GOA, TRIP_ID, DAYS)])[, .(MEAN_TRIP_DAYS = mean(DAYS)), keyby = .(ADP, STRATA, BSAI_GOA)]
# trip_cost_mixed_fmp_dt[
# ][, CPD := fcase(
#   STRATA %like% "EM_TRW", trwem_cpd,
#   STRATA %like% "EM_HAL|EM_POT|EM_MIXED", fgem_cpd,
#   STRATA %like% "OB_HAL|OB_POT|OB_MIXED|OB_TRW", ob_cpd)
# ][, CPT := MEAN_TRIP_DAYS * CPD
# ][STRATA == "ZERO", ':=' (CPD = 0, CPT = 0)
# ][, STRATUM_COL := paste0(STRATA, "-", BSAI_GOA)]
# # Redefine strata for equal rates and min+opt functions, merge in day costs
# allo_mixed_fmp_lst <- update_strata(pc_effort_mixed, trips_melt, stratum_cols = c("STRATA", "BSAI_GOA"), focus_years = 2018:2022)
# allo_mixed_fmp_lst$effort[, CPD := trip_cost_mixed_fmp_dt[allo_mixed_fmp_lst$effort, CPD, on = c(ADP = "ADP", STRATUM_COL = "STRATA")]]


#====================#
# Compile Results ---- 
#====================#

trip_counts <- list (
  CURRENT   = val_2018_2022_dt[, .(N = uniqueN(TRIP_ID)), keyby = .(ADP, STRATA)],
  FMP       = val_2018_2022_dt[, .(N = uniqueN(TRIP_ID)), keyby = .(ADP, STRATA, BSAI_GOA)],
  FIXED     =        val_fixed[, .(N = uniqueN(TRIP_ID)), keyby = .(ADP, STRATA)],
  FIXED_FMP =        val_fixed[, .(N = uniqueN(TRIP_ID)), keyby = .(ADP, STRATA, BSAI_GOA)], 
  MIXED     =        val_mixed[, .(N = uniqueN(TRIP_ID)), keyby = .(ADP, STRATA)],
  MIXED_FMP =        val_mixed[, .(N = uniqueN(TRIP_ID)), keyby = .(ADP, STRATA, BSAI_GOA)]
)


rates_lst <- list(
  
  # Equal Rates 
  EQUAL = list(EQUAL = equal_rates),
  
  # Current stratification
  CURRENT = list(
    MPO_SQ = mpo_sq_rates,
    MPO = mpo_rates,
    MPO_50 = mpo_50_rates,
    CWB = cwb_rates$rates,
    PROX = prox_rates
  ), 
  
  FMP = list(
    MPO_SQ_FMP = mpo_sq_fmp_rates,
    MPO_FMP = mpo_fmp_rates,
    MPO_50_FMP = mpo_50_fmp_rates,
    CWB_FMP = cwb_fmp_rates$rates,
    PROX_FMP = prox_fmp_rates
  ),
  
  FIXED = list(
    MPO_SQ_FIXED = mpo_sq_fixed_rates,
    MPO_FIXED = mpo_fixed_rates,
    CWB_FIXED = cwb_fixed_rates$rates,
    CWB_FIXED_GS = cwb_fixed_gs_rates$rates,
    PROX_FIXED = prox_fixed_rates,
    PROX_FIXED_GS = prox_fixed_gs_rates
  ),
  
  FIXED_FMP = list(
    MPO_SQ_FIXED_FMP = mpo_sq_fixed_fmp_rates,
    MPO_FIXED_FMP = mpo_fixed_fmp_rates,
    CWB_FIXED_FMP = cwb_fixed_fmp_rates$rates,
    CWB_FIXED_FMP_GS = cwb_fixed_fmp_gs_rates$rates,
    PROX_FIXED_FMP = prox_fixed_fmp_rates,
    PROX_FIXED_FMP_GS = prox_fixed_fmp_gs_rates
  ),
  
  MIXED = list(
    MPO_SQ_MIXED = mpo_sq_mixed_rates,
    MPO_MIXED = mpo_mixed_rates,
    CWB_MIXED = cwb_mixed_rates$rates,
    PROX_MIXED = prox_mixed_rates
  )
  
)

# Make a unified column of sample rate
rates_lst_unlist <- unlist(rates_lst, recursive = F)
for(i in names(rates_lst_unlist)) {
  if(i %like% "EQUAL|MPO") rates_lst_unlist[[i]] <- rates_lst_unlist[[i]][, RATE := MON_RATE][]
  if(i %like% "CWB") rates_lst_unlist[[i]] <- rates_lst_unlist[[i]][, RATE := fh][]
  if(i %like% "PROX") rates_lst_unlist[[i]] <- rates_lst_unlist[[i]][, RATE := SAMPLE_RATE][]
}

# Assign monitoring method as a fill color
fill_col <- function(x) {
  x[, FILL := fcase(
    STRATA %like% "EM_TRW", "EM_TRW", 
    STRATA %like% "EM_HAL|EM_POT|EM_FIXED|EM_MIXED", "FG_EM", 
    STRATA %like% "OB", "OB")][]
}
rates_lst_unlist <- lapply(rates_lst_unlist, fill_col)

# Make a unified STRATUM_COL across all designs
for(i in names(rates_lst_unlist)) {
  if(i %like% "EQUAL|MPO") rates_lst_unlist[[i]] <- rates_lst_unlist[[i]][, STRATUM_COL := gsub("[-]", "*", STRATA)][]
  
  if(i %like% "CWB|PROX" & !(i %like% "FMP")) {
    rates_lst_unlist[[i]] <- rates_lst_unlist[[i]][, STRATUM_COL := STRATA][]
  }
  if(i %like% "CWB|PROX" &   i %like% "FMP" ) {
    rates_lst_unlist[[i]] <- rates_lst_unlist[[i]][, STRATUM_COL := paste0(STRATA, "*", BSAI_GOA)][]
  }
  
}

# Apply this to the trip counts as well
for(i in names(trip_counts)) {
  if(i %like% "FMP") {
    trip_counts[[i]] <- trip_counts[[i]][, STRATUM_COL := paste0(STRATA, "*", BSAI_GOA)]
  } else {
    trip_counts[[i]] <- trip_counts[[i]][, STRATUM_COL := STRATA]
  }
}

rates_lst <- rates_lst_unlist # Replace and save

# TODO SAVE ALL THE BOX DEFINITIONS TOO!!!

#======================================================================================================================#
# Evaluation - Domain Interspersion ------------------------------------------------------------------------------------
#======================================================================================================================#

# for each stratification scheme, specify the box definition and  make the acceptor/donor list
# then for each allocation scheme, just plug in the selection rates

# TODO see if the box definitions differ between gear-specific or not (THEY SHOULDN'T, BUT CHECK!)
# TODO Do within-strata evaluation, and then also observer to all other method comparisons

# Ideally the plots will line up, so we don't want to drop any unused levels

# Remake a new plot sequence has has all these in one? Have to make a new summary function
# On top, have the monitoring-method specific comparisons
#    FG_EM-FG_EM, TRW_EM-TRW_EM, and OB-OB
# Below, have cross-pool comparisons
#   OB-FG_EM and OB-ZERO
# Y-axis (HAL-POT-TRW), (reverse current axes)
# X-axis (domain interspersion)
# Facets ADP ~ Comparison type and FMP if needed. 
# TODO have overall and FMP-specific on the same plot? Overall on top and FMP below? Have to be two 
# separate plots, lining them up might not work out so well?

# For each, need the box def's stratum_cols along with ADP and rate as SAMPLE_RATE. Keep STRATUM_COL
# for convenience?

eval_rates <- vector(mode = "list", length = length(rates_lst))
for(i in 1:length(rates_lst)) {
  
  grab_cols <- c("ADP", "STRATUM_COL", "FILL", "STRATA", "RATE")
  strat_scheme <-  unlist(strsplit(names(rates_lst)[[i]], split = "[.]"))[1] 
  allo_scheme <- unlist(strsplit(names(rates_lst)[[i]], split = "[.]"))[2] 
  
  if( strat_scheme %like% "FMP"){
    # IF FMPis in the strat_scheme, Have to recreate BSAI_GOA col from the equal/mpo allocation methods
    if( allo_scheme %like% "EQUAL|MPO" ) {
      design_rates <- rates_lst[[i]][, ..grab_cols]
      design_rates[, c("STRATA", "BSAI_GOA") := tstrsplit(STRATUM_COL, split = "[*]")]
    } else {
      grab_cols <- c(grab_cols, "BSAI_GOA")
      design_rates <- rates_lst[[i]][, ..grab_cols]
    }
  } else {
    design_rates <- rates_lst[[i]][, ..grab_cols]
  }

  setnames(design_rates, "RATE", "SAMPLE_RATE")
  eval_rates[[i]] <- design_rates

}
names(eval_rates) <- names(rates_lst)

#----------------------------------------------------------------------------------------------------------------------#
## SANDBOX --------------------------------------------------------------------------------------------------------------
#----------------------------------------------------------------------------------------------------------------------#

# Here is a small collection of data objects to act as a sandbox for some of our evaluations
pc_effort.current <- copy(pc_effort_dt)[, STRATUM_COL := STRATA][ADP == 2022]
pc_effort.fixed_fmp <- copy(pc_effort_fixed)[, STRATUM_COL := paste0(STRATA, "*", "BSAI_GOA")][ADP == 2022]
# get 2022 rates for equal rates and proximity allocation schemes for status quo and FIXED_FMP stratifications
rates_2022 <- lapply(eval_rates, function(x) x[ADP == 2022, ])[c("CURRENT.MPO_SQ", "CURRENT.PROX", "FIXED_FMP.MPO_SQ_FIXED_FMP", "FIXED_FMP.PROX_FIXED_FMP_GS")]
if(F)  save(pc_effort.current, pc_effort.fixed_fmp, rates_2022, allo_lst, allo_fixed_fmp_lst, file = "analyses/stratification/sandbox.Rdata")

#----------------------------------------------------------------------------------------------------------------------#




# Make a vector of all designs and the stratifications they use
design_stratification <- sapply(names(eval_rates), function(x) unlist(strsplit(x, split = "[.]"))[1] )
# The value is the stratum, the name is the design

#=============#
## Current ----
#=============#

# box_sq$dmn$strata_dt
current.OB.acceptor_donor_lst <- c(
  rep(list(4:5), times = 2),                # 1-2: EM_HAL and EM_POT 
  list(3),                                  # 3: EM_TRW
  rep(list(4:5), times = 2),                # 4-5: OB Fixed Gear
  list(6),                                  # 6: OB Trawl                         
  list(4:5)                                 # 7: ZERO           
)

current.nonOB.acceptor_donor_lst <- c(
  rep(list(1:2), times = 2),                # 1-2: Fixed-gear EM to itself
  rep(list(NULL), times = 5)                # 4-7: No other donors
)

current_designs <- names(design_stratification[design_stratification %in% c("EQUAL", "CURRENT")])
current_figs <- vector(mode = "list", length = length(current_designs))
for(i in 1:length(current_designs )) {
  current_figs[[i]] <- dmn_interspersion_figs(
    box_def = box_sq,
    selection_rates = eval_rates[[ current_designs[[i]] ]],
    ob_adl = current.OB.acceptor_donor_lst,
    nonob_adl = current.nonOB.acceptor_donor_lst
  )
}
names(current_figs) <- current_designs

#=========#
## FMP ----
#=========#

# box_fmp$dmn$strata_dt
fmp.OB.acceptor_donor_lst <- c(
  rep(list(6:9), times = 4),                # 1-4:   EM_HAL and EM_POT 
  list(5),                                  # 5:     EM_TRW
  rep(list(6:9), times = 4),                # 6-9:   OB Fixed Gear
  rep(list(10:11), times = 2),              # 10-11: OB Trawl                         
  rep(list(6:9), times = 2)                 # 12-13: ZERO           
)

fmp.nonOB.acceptor_donor_lst <- c(
  rep(list(1:4), times = 4),               # 1-4: Fixed-gear EM to itself
  rep(list(NULL), times = 9)               # 5-13: No other donors
)

fmp_designs <- names(design_stratification[design_stratification == "FMP"])
fmp_figs <- vector(mode = "list", length = length(fmp_designs))
for(i in 1:length(fmp_designs)) {
  fmp_figs[[i]] <- dmn_interspersion_figs(
    box_def = box_fmp,
    selection_rates = eval_rates[[ fmp_designs[[i]] ]],
    ob_adl = fmp.OB.acceptor_donor_lst,
    nonob_adl = fmp.nonOB.acceptor_donor_lst
  )
}
names(fmp_figs) <- fmp_designs

#===========#
## Fixed ----
#===========#

# box_fixed$dmn$strata_dt
fixed.OB.acceptor_donor_lst <- c(
  list(3),                # 1: EM Fixed Gear
  list(2),                # 2: EM Trawl
  list(3),                # 3: OB Fixed Gear
  list(4),                # 4: OB Trawl                         
  list(3)                 # 5: ZERO           
)

fixed.nonOB.acceptor_donor_lst <- c(
  list(1),                       # 1: Fixed-gear EM to itself
  rep(list(NULL), times = 4)     # 2-5: No other donors
)

fixed_designs <- names(design_stratification[design_stratification == "FIXED"])
fixed_figs <- vector(mode = "list", length = length(fixed_designs))
for(i in 1:length(fixed_designs)) {
  fixed_figs[[i]] <- dmn_interspersion_figs(
    box_def = box_fixed,
    selection_rates = eval_rates[[ fixed_designs[[i]] ]],
    ob_adl = fixed.OB.acceptor_donor_lst,
    nonob_adl = fixed.nonOB.acceptor_donor_lst
  )
}
names(fixed_figs) <- fixed_designs

#=================#
## Fixed X FMP ----
#=================#

# box_fixed_fmp$dmn$strata_dt
fixed_fmp.OB.acceptor_donor_lst <- c(
  rep(list(4:5), times = 2),                # 1-2:   EM Fixed Gear
  list(3),                                  # 3:     EM Trawl
  rep(list(4:5), times = 2),                # 4-5:   OB Fixed Gear
  rep(list(6:7), times = 2),                # 6-7: OB Trawl                         
  rep(list(4:5), times = 2)                 # 8-9: ZERO           
)

fixed_fmp.nonOB.acceptor_donor_lst <- c(
  rep(list(1:2), times = 2),               # 1-2: Fixed-gear EM to itself
  rep(list(NULL), times = 7)               # 3-9: No other donors
)

fixed_fmp_designs <- names(design_stratification[design_stratification == "FIXED_FMP"])
fixed_fmp_figs <- vector(mode = "list", length = length(fixed_fmp_designs))
for(i in 1:length(fixed_fmp_designs)) {
  fixed_fmp_figs[[i]] <- dmn_interspersion_figs(
    box_def = box_fixed_fmp,
    selection_rates = eval_rates[[ fixed_fmp_designs[[i]] ]],
    ob_adl = fixed_fmp.OB.acceptor_donor_lst,
    nonob_adl = fixed_fmp.nonOB.acceptor_donor_lst
  )
}
names(fixed_fmp_figs) <- fixed_fmp_designs

#===========#
## Mixed ----
#===========#

# box_mixed$dmn$strata_dt
mixed.OB.acceptor_donor_lst <- c(
  rep(list(5:7), times = 3),            # 1-3:  EM Fixed Gear
  list(4),                              # 4:    EM Trawl
  rep(list(5:7), times = 3),            # 5-7:  OB Fixed Gear
  list(8),                              # 8:    OB Trawl                         
  list(5:7)                             # 9:    ZERO           
)

mixed.nonOB.acceptor_donor_lst <- c(
  rep(list(1:3), times = 3),            # 1-3: Fixed-gear EM to itself
  rep(list(NULL), times = 6)            # 4-9: No other donors
)

mixed_designs <- names(design_stratification[design_stratification == "MIXED"])
mixed_figs <- vector(mode = "list", length = length(mixed_designs))
for(i in 1:length(mixed_designs)) {
  mixed_figs[[i]] <- dmn_interspersion_figs(
    box_def = box_mixed,
    selection_rates = eval_rates[[ mixed_designs[[i]] ]],
    ob_adl = mixed.OB.acceptor_donor_lst,
    nonob_adl = mixed.nonOB.acceptor_donor_lst
  )
}
names(mixed_figs) <- mixed_designs

#=====================#
## Combine Figures ----
#=====================#

# Set identical widths once we get all designs done!
figs_overall <- unlist(list(
  lapply(current_figs, "[[", "DMN_PLOT_OVERALL"),
  lapply(fmp_figs, "[[", "DMN_PLOT_OVERALL"),
  lapply(fixed_figs, "[[", "DMN_PLOT_OVERALL"),
  lapply(fixed_fmp_figs, "[[", "DMN_PLOT_OVERALL"),
  lapply(mixed_figs, "[[", "DMN_PLOT_OVERALL")
), recursive = F)

figs_overall_grobs <- lapply(figs_overall, ggplotGrob)
figs_overall_widths_lst <- lapply(figs_overall_grobs, function(x) x[["widths"]])
figs_overall_width <- do.call(unit.pmax, figs_overall_widths_lst)
for(i in 1:length(figs_overall_grobs)) figs_overall_grobs[[i]]$widths <- figs_overall_width

figs_fmp <- unlist(list(
  lapply(current_figs, "[[", "DMN_PLOT_FMP"),
  lapply(fmp_figs, "[[", "DMN_PLOT_FMP"),
  lapply(fixed_figs, "[[", "DMN_PLOT_FMP"),
  lapply(fixed_fmp_figs, "[[", "DMN_PLOT_FMP"),
  lapply(mixed_figs, "[[", "DMN_PLOT_FMP")
), recursive = F)

figs_fmp_grobs <- lapply(figs_fmp, ggplotGrob)
figs_fmp_widths_lst <- lapply(figs_fmp_grobs, function(x) x[["widths"]])
figs_fmp_width <- do.call(unit.pmax, figs_fmp_widths_lst)
for(i in 1:length(figs_fmp_grobs)) figs_fmp_grobs[[i]]$widths <- figs_fmp_width

# Now combine the figures!
figs_combined_grobs <- mapply(
  FUN = function(overall, fmp) arrangeGrob(overall, fmp, ncol = 1),
  overall = figs_overall_grobs,
  fmp = figs_fmp_grobs
)

# All results of domain interspersion (save this to a different file - kind of big with all the spatial data)
dmn_insp_list <- unlist(list(
  current_figs,
  fmp_figs,
  fixed_figs,
  fixed_fmp_figs,
  mixed_figs
), recursive = F)

# Package up box definitions

box_lst <- list(
  CURRENT = box_sq,
  FMP = box_fmp,
  FIXED = box_fixed,
  FIXED_GS = box_fixed_gs,
  FIXED_FMP = box_fixed_fmp,
  FIXED_FMP_GS = box_fixed_fmp_gs,
  MIXED = box_mixed
)

costs_lst<- list(
  CURRENT = trip_cost_dt,
  FMP = trip_cost_fmp_dt,
  FIXED = trip_cost_fixed_dt,
  FIXED_FMP = trip_cost_fixed_fmp_dt,
  MIXED = trip_cost_mixed_dt
)

# Run this if you want to save/overwrite the results!
if(F) {
  save(dmn_insp_list, file = "analyses/stratification/dmn_insp_list.rdata")
  save(trip_counts, rates_lst, figs_combined_grobs, file = "analyses/stratification/rates_lst.rdata")
  save(box_lst, costs_lst, file = "analyses/stratification/boxes_and_costs.rdata")
}

# TODO SAVE BOX DEFINITIONS AND COSTS BY STRATIFICATION


# TODO could also see what happens IF we allow FG_EM to apply to ZERO in addition to OB. However, ideally
# we would set the probability up as IF there is no observer data, what would be the additional probability
# that the ZERO trip is neighboring an fixed-gear EM trip (because as-is it would calculate the probablity
# that of neighboring an OB trip and FG_EM trip simultaneously)



# Tracking between PROX interspersion and evaluation ----

rates_lst$FIXED.PROX_FIXED_GS[ADP == 2022]
# TODO save the actual values that go into the plots (dmn_insp values)
# dmn_insp_list$FIXED.PROX_FIXED$DMN_INSP_OB$POOLED[ADP == 2022][, .(INSP = sum())by = .(POOL, GEAR)]

#======================================================================================================================#
# Maps ? ---------------------------------------------------------------------------------------------------------------
#======================================================================================================================#

dmn_insp_list$CURRENT.PROX$DMN_INSP_OB  # Use $POOLED (has pool defined) with $GEOM which has spatial data for HEX_ID

dmn_insp_list$CURRENT.PROX$DMN_INSP_OB$POOLED[
][ADP == 2022]





#==========================#
# OLD - Testing of Evaluation ----
#==========================#

target_budget <- data.table(ADP = 2022L, INDEX_COST = 4.5e6)
box_fixed_index$rates[, .SD[target_budget, on = .(ADP, INDEX_COST), roll = "nearest"], by = .(STRATA)]
box_fixed_gs_index$rates[, .SD[target_budget, on = .(ADP, INDEX_COST), roll = "nearest"], by = .(STRATA)]
box_fixed_bsai_goa_gs_index$rates[, .SD[target_budget, on = .(ADP, INDEX_COST), roll = "nearest"], by = .(STRATA, BSAI_GOA)]
# Only 8% in all if fixed-gear GOA, but all other strata have pretty high rates. How this pans out allocation-wise will be interesting
box_fixed_bsai_goa_gs_index$rates[, .SD[target_budget, on = .(ADP, INDEX_COST), roll = "nearest"], by = .(STRATA, BSAI_GOA)][STRATA %like% "EM_FIXED", sum(n * CPT)]
# It allocates around $640K to fixed-gear EM, opposed to $1M under status quo

donor_ob_fixed_bsai_goa <- data.table(STRATA = rep(c("OB_FIXED", "OB_TRW"), each = 2), BSAI_GOA = rep(c("BSAI", "GOA"), times = 2))
target_budget_all_years <- data.table(ADP = 2018:2022, INDEX_COST = 4.5e6)


box_fixed_bsai_goa$dmn$strata_dt  #UMM THIS IS NOT WHAT I WANTED
allo_prox_fixed_bsai_goa_acceptor_donor_lst <- c(
  rep(list(4:5), times = 2),                # 1-2: EM_HAL and EM_POT 
  list(3),                                  # 3: EM_TRW
  rep(list(4:5), times = 2),                # 4-5: OB_Mixed
  rep(list(6:7), times = 2),                # 6-7: OB_TRW                            
  rep(list(4:5), times = 2)                 # 8-9:  ZERO           
)

# Evaluation for FG_combed + BSAI_GOA (NOT gear-specific)
allo_prox_fixed_bsai_goa <- calculate_dmn_interspersion3(
  box_fixed_bsai_goa,
  selection_rates = box_fixed_bsai_goa_index$rates[, .SD[target_budget_all_years, on = .(ADP, INDEX_COST), roll = "nearest"], by = .(STRATA, BSAI_GOA)],
  acceptor_donor_lst = allo_prox_fixed_bsai_goa_acceptor_donor_lst
)
allo_prox_fixed_bsai_smry  <- dmn_interspersion_smry(allo_prox_fixed_bsai_goa)
allo_prox_fixed_bsai_plots <- dmn_interspersion_plot(allo_prox_fixed_bsai_goa)  # FIXME make the plots ordered by year_col
allo_prox_fixed_bsai_smry$BSAI_GOA

# Evaluation for FG_combed + BSAI_GOA (gear-specific)
allo_prox_fixed_bsai_goa_gs <- calculate_dmn_interspersion3(
  box_fixed_bsai_goa_gs,
  selection_rates = box_fixed_bsai_goa_gs_index$rates[, .SD[target_budget_all_years, on = .(ADP, INDEX_COST), roll = "nearest"], by = .(STRATA, BSAI_GOA)],
  acceptor_donor_lst = allo_prox_fixed_bsai_goa_acceptor_donor_lst
)
allo_prox_fixed_bsai_gs_smry  <- dmn_interspersion_smry(allo_prox_fixed_bsai_goa_gs)
allo_prox_fixed_bsai_gs_plots <- dmn_interspersion_plot(allo_prox_fixedd_bsai_goa_gs)  # FIXME make the plots ordered by year_col
allo_prox_fixed_bsai_gs_smry$BSAI_GOA

a <- rbind(
  cbind(Method = "combined",      allo_prox_fixed_bsai_smry$BSAI_GOA),
  cbind(Method = "gear-specific", allo_prox_fixed_bsai_gs_smry$BSAI_GOA)
)
a[, sum(POOL_DMN_INTERSPERSION), keyby = .(ADP, Method)]
ggplot(a, aes(x = BSAI_GOA, y = POOL_DMN_INTERSPERSION, fill = Method)) + facet_grid(ADP ~ POOL + GEAR) + geom_col(position = position_dodge())

a1 <- as.data.table(cbind(
  combined = allo_prox_fixed_bsai_smry$BSAI_GOA$POOL_DMN_INTERSPERSION,
  gs = allo_prox_fixed_bsai_gs_smry$BSAI_GOA$POOL_DMN_INTERSPERSION
))
a1[, DIFF := gs - combined]
sum(a1$DIFF)  # by BSAI, gear-specific did better
ggplot(a1, aes(x = DIFF)) + geom_histogram()
# Also, overall, gear-specific did better (as should be expected since the allocation more closely matches the evaluation)
sum(allo_prox_fixed_bsai_gs_smry$OVERALL$POOL_DMN_INTERSPERSION) - sum(allo_prox_fixed_bsai_smry$OVERALL$POOL_DMN_INTERSPERSION)


# Difference of having EM strata set at status quo rates or not, with current stratification, compared to equal rates
allo_er[ADP==2022 & STRATA %like% "OB", sum(MON_N)]
allo_sq_mpo[ADP==2022 & STRATA %like% "OB", sum(MON_N)]
allo_er[ADP==2022 & STRATA %in% c("EM_HAL", "EM_POT"), sum(CPD * STRATA_N * MON_RATE * TRP_DUR)]
allo_sq_mpo[ADP==2022 & STRATA %in% c("EM_HAL", "EM_POT"), sum(CPD * STRATA_N * MON_RATE * TRP_DUR)]



# OLD - Testing a slightly larger budget ($5.25M?) ----

mpo_525 <- allo_min_plus_opt(allo_lst, em_carve_off = F, conf = 0.95, MIN_RATE = 0.15, budget = 5.25e6)
mpo_bsai_goa_525 <- allo_min_plus_opt(allo_bsai_goa_lst, em_carve_off = F, conf = 0.95, MIN_RATE = 0.15, budget = 5.25e6)
# If we don't split by BSAI, 5.25 affords optimized samples all years.
# If we DO split by BSAI_GOA, can't afford optimized samples in 2018 or 2022

mpo_525[ADP == 2021, .(ADP, STRATA, STRATA_N, MON_RATE, CONF_RATE, W_hopt, OPT_N)]
mpo_bsai_goa_525[ADP == 2021, .(ADP, STRATA, STRATA_N, MON_RATE, CONF_RATE, W_hopt, OPT_N)]
# The sample rates can differ a lot based on the adjusted hurdle
# OB_TRW-GOA, EM_HAL-GOA and OB_HAL-GOA actually get the most optimized samples
# Remember that W_hopt is the weight of remaining dollars that are allocated to additional
# samples. EM_TRW actually gets 64 or 42 additional trips sampled 
# In 2021 (not split by BSAI_GOA), OB_HAL actually has a higher W_hopt than any other stratum including TRW?
# TODO getting the blended metric would be interesting so see balance with cost and stratum size