---
title: "Preliminary Rates"
author: "Geoff_Mayhew"
date: "2023-07-17"
output: html_document
---


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, fig.width = 8, fig.height = 3)
library(data.table)
library(ggplot2)
library(magrittr)  # for piping
library(flextable)
library(grid)
library(gridExtra)
library(scales)    # for gradient color mapping with col_numeric
```

```{r load data, include = F}
load("rates_lst.rdata")  #  https://drive.google.com/file/d/1DnkWWMCCM9L97ccHXWTjVpB3iJ8NHzxa/view?usp=drive_link

# https://drive.google.com/file/d/1VWYiW8poe3jJq2r-3ZzunmuURvfwG2wF/view?usp=drive_link
load("../../analyses/allocation_evaluation/allocation_evaluation.Rdata")   # loads pc_effort_dt and trips_melt

max_rate <- max(unlist(sapply(rates_lst, "[[", "RATE")))

plot_formats <- list(
  labs(y = "Stratum", x = "Selection Rate"),
  scale_y_discrete(limits = rev),
  scale_fill_manual(values = c("dodgerblue", "dodgerblue4", "chartreuse3")),
  theme(legend.position = "none", axis.text.y = element_text(hjust = 0)),
  scale_x_continuous(limits = c(0, max_rate), breaks = seq(0, 1, by = 0.05)) 
)

# Make all the plots, filtering 2022 results only
rates_2022 <- lapply(rates_lst, function(x) x[ADP == 2022])
plot_lst <- lapply(
  rates_2022,
  function(x) ggplot(x[, .(ADP, STRATUM_COL, RATE, FILL)], aes(x = RATE, y = STRATUM_COL)) + 
  facet_grid(ADP ~ .) + geom_col(aes(fill = FILL)) + 
  plot_formats
)

# Add the trip counts to each plot
trip_counts <- lapply(trip_counts, function(x) x[ADP == 2022][order(ADP, STRATUM_COL)][!STRATUM_COL %like% "ZERO"])
for(i in 1:length(plot_lst)) {
  strat_name <- unlist(strsplit(split = "[.]", names(plot_lst)[[i]]))[1]
  if(strat_name == "EQUAL") strat_name <- "CURRENT"
  plot_lst[[i]] <- plot_lst[[i]] + 
    geom_text(data = trip_counts[[strat_name]], aes(label = N, x = max_rate), size = 2.5, hjust = 1)
}

# Make all plots have the same widths
grob_lst <- lapply(plot_lst, ggplotGrob)
widths_lst <- lapply(grob_lst, function(x) x[["widths"]])
plot_widths <- do.call(unit.pmax, widths_lst)
for(i in 1:length(grob_lst)) grob_lst[[i]]$widths <- plot_widths
# to call the plot, use the syntax:   grid.arrange(grob_lst$EQUAL.EQUAL)

# Get 2022 tip counts split by BS vs AI vs GOA
strata_N_2022 <- pc_effort_dt[ADP == 2022 & STRATA != "ZERO", .(N = uniqueN(TRIP_ID)), keyby = .(STRATA, BS_AI_GOA)]
strata_N_2022[, GEAR := tstrsplit(STRATA, split="_")[[2]]]
strata_N_2022[, c("MON", "GEAR") := tstrsplit(STRATA, split = "_")]

fmp_tbl <- data.table(BSAI_GOA = c("BSAI", "BSAI", "GOA"), BS_AI_GOA = c("BS", "AI", "GOA"))
gear_tbl <- data.table(STRATA = c("EM_FIXED", "EM_FIXED", "EM_TRW", "OB_FIXED", "OB_FIXED", "OB_TRW"), GEAR = c("HAL", "POT", "TRW", "HAL", "POT", "TRW"))

# Get sample sizes from each design. Unify the outputs so we can apply rates to N for each BS/AI/GOA X Monitoring tool X Gear combination
n_2022 <- lapply(rates_2022, function(x) {
  
  x1 <- copy(x)
  x1[, c("MON", "GEAR") := tstrsplit(STRATUM_COL, split = "_")]
  if( any(x1$STRATUM_COL %like% c("BSAI|GOA")) & !("BSAI_GOA" %in% colnames(x1)) )  {
    x1[, BSAI_GOA := gsub("^.*[*]", "", GEAR)]
    x1[, STRATA := gsub("[-].*$", "", STRATA)]
    }
  x1[, GEAR := gsub("[*].*$", "", GEAR)]   # for cases where STRATUM_COLhad BSAI_GOA included and are now in GEAR, remove it
  
  # If BSAI_GOA not included, just repeat for BS, AI, and GOA
  if( !("BSAI_GOA" %in% colnames(x1)) ) {
    x1 <- x1[
    ][, as.list(data.table(BS_AI_GOA = c("BS", "AI", "GOA"))), by = x1         # Cross join with BS, AI, and GOA
    ][!(STRATUM_COL %like% "EM_TRW" & BS_AI_GOA %in% c("BS", "AI"))]
  } else {
    # if BSAI_GOA is present, then split BSAI into BS and AI
    x1 <- x1[fmp_tbl, on = .(BSAI_GOA), allow.cartesian = T]
  }
  
  # For FIXED_FMP stratification, split fixed into HAL and POT
  if( any(x1$GEAR == "FIXED") ) {
    x1 <- x1[, - "GEAR"][gear_tbl, on = .(STRATA)]
  }
  
  # Final output
  x1[, .(MON, GEAR, BS_AI_GOA, RATE)][order(MON, GEAR, BS_AI_GOA, RATE)]
  
})
# Merge in the rates with trip counts, calculate sample size and probability of zero trips monitored.
n_2022 <- lapply(n_2022, function(x) {
  x1 <- x[strata_N_2022[, .(MON, GEAR, BS_AI_GOA, N)], on = .(MON, GEAR, BS_AI_GOA)]
  x1[, n := floor(N * RATE)]
  x1[, `P(0)` := round((1-RATE)^N, 4)]
  x1[, MON := ifelse(MON == "EM", ifelse(GEAR == "TRW", "EM + Observer", "EM"), "Observer")]
  x1[order(MON, GEAR, BS_AI_GOA)]
})

# Define color gradient function
p0_gradient <- col_numeric(palette = c("white", "red"), domain = c(0, 1))

# Create flextables, coloring P(0) cells 
n_2022_flex <- lapply(n_2022, function(x) {
  x %>%
    flextable() %>% colformat_double(j = c(4,7), digits = 4) %>%
    set_header_labels(values = list(MON = "Monitoring Tool", GEAR = "Gear Type", BS_AI_GOA = "BS/AI/GOA", RATE = "Rate")) %>%
    merge_v(j = c(1,2)) %>% hline(part = "all") %>% padding(padding = 0.1) %>% autofit() %>% bold(part = "header") %>%
    bg(j = 7, bg = p0_gradient)
})

```


# Preliminary rates with a $4.5M budget {.tabset .tabset-pills}

Select a stratification scheme and then an allocation scheme. The equal rates allocation scheme was only applied to the 'Current' stratification scheme. Note that the tabs remember which allocation scheme is selected within each stratification, so you can also compare how the same allocation method responds to changes in stratification. The tables below show the resulting sample sizes ( *n* as floor(*N* x *Rate*) ) and the probabilities of getting 0 trips sampled ( P(0) = (1-Rate)^n ) by each monitor tool, gear type, and BS vs AI vs GOA combination.

## Current {.tabset .tabset-pills}

### Equal Rates
```{r}
grid.arrange(grob_lst$EQUAL.EQUAL)
n_2022_flex$EQUAL.EQUAL
```

### MPO (SQ)
```{r}
grid.arrange(grob_lst$CURRENT.MPO_SQ)
n_2022_flex$CURRENT.MPO_SQ
```

### MPO
```{r}
grid.arrange(grob_lst$CURRENT.MPO)
n_2022_flex$CURRENT.MPO
```

### CWB
```{r}
grid.arrange(grob_lst$CURRENT.CWB)
n_2022_flex$CURRENT.CWB
```

### PROX
```{r}
grid.arrange(grob_lst$CURRENT.PROX)
n_2022_flex$CURRENT.PROX
```


## FMP {.tabset .tabset-pills}

### MPO (SQ)
```{r}
grid.arrange(grob_lst$FMP.MPO_SQ_FMP)
n_2022_flex$FMP.MPO_SQ_FMP
```

### MPO
```{r}
grid.arrange(grob_lst$FMP.MPO_FMP)
n_2022_flex$FMP.MPO_FMP
```

### CWB
```{r}
grid.arrange(grob_lst$FMP.CWB_FMP)
n_2022_flex$FMP.CWB_FMP
```

### PROX
```{r}
grid.arrange(grob_lst$FMP.PROX_FMP)
n_2022_flex$FMP.PROX_FMP
```


## Fixed FMP {.tabset .tabset-pills}

### MPO (SQ)
```{r}
grid.arrange(grob_lst$FIXED_FMP.MPO_SQ_FIXED_FMP)
n_2022_flex$FIXED_FMP.MPO_SQ_FIXED_FMP
```

### MPO
```{r}
grid.arrange(grob_lst$FIXED_FMP.MPO_FIXED_FMP)
n_2022_flex$FIXED_FMP.MPO_FIXED_FMP
```

### CWB
```{r}
grid.arrange(grob_lst$FIXED_FMP.CWB_FIXED_FMP_GS)
n_2022_flex$FIXED_FMP.CWB_FIXED_FMP_GS
```

### PROX
```{r}
grid.arrange(grob_lst$FIXED_FMP.PROX_FIXED_FMP_GS)
n_2022_flex$FIXED_FMP.PROX_FIXED_FMP_GS
```