---
title: "Evaluating fisheries data quality for inseason management"
author: "Phil Ganz"
date: "`r Sys.Date()`"
output: html_document
editor_options: 
  chunk_output_type: console
---

```{r setup, echo = FALSE, message = FALSE}
# Get packages ----
library(data.table)
library(gridExtra)
library(lubridate)
library(pals)
library(ROracle)
library(scales)
library(tidyverse)

# Load data ----
load("analyses/inseason_management/valhalla_accounts.RData")  

# Most recent full year ----
year <- year(Sys.Date()) - 1

# Figure theme ----
fig_theme <- list(theme_classic(), scale_y_continuous(labels = comma), scale_fill_manual(values = kelly()[2:22]))

# Do not print code chunks by default ----
knitr::opts_chunk$set(echo = FALSE)
```

# Introduction
One of the purposes for which fishery-dependent data are used is inseason management, broadly defined as the opening and closing of fisheries throughout the year based on the proportion of total allowable catch (TAC) that has been harvested or the proportion of prohibited species catch (PSC) that has been caught, relative to PSC limits. Catch that accrues toward TAC or PSC limits is tracked by the Catch Accounting System (CAS) within different accounts that are typically defined by area, species caught, and gear type (e.g. ). Account definitions sometimes also include management program or processing sector (e.g. ). Regardless, these are the units within which catch is tracked by inseason management.

# The Goal of This Analysis
The goal of this analysis is to identify a metric that can be used to differentiate the performance of different sampling designs with regards to providing data for inseason management. It's important to note that the goal is *not* to identify the absolute best metric for measuring design performance for inseason management; the metric only needs to be accurate enough to differentiate between the performance of different sampling designs. The goal is also *not* to quantify how much data is needed for inseason management.

# What's a Good Sampling Design for Inseason Mangement?
Catch is either retained or discarded. Retained catch is known, whereas discarded catch is estimated. More sampling won't benefit inseason management if it's directed toward a fishery that retains all catch. Discard estimates are made using data from fisheries observers or electronic monitoring (EM). With more precise estimates, an inseason manager is able to close a fishery closer to its TAC or PSC limit. Therefore, a sampling design that dedicates more sampling toward fisheries with a lot of highly variable discards will outperform a design that puts more sampling toward fisheries with small amounts of discards with little variance.

It's therefore helpful to visualize how much of the catch in each account is made up of discards:  
```{r accounts_discard}
accounts_discard <- valhalla %>% 
                    filter(ADP == 2021 & ACCOUNT_NAME != "No Account") %>% 
                    mutate(DISCARD_FLAG = recode(SOURCE_TABLE, 'Y' = 'N', 'N' = 'Y')) %>% 
                    group_by(ACCOUNT_NAME, DISCARD_FLAG) %>%
                    summarise(weight = sum(WEIGHT_POSTED, na.rm = TRUE),
                              count  = sum(SPECIES_COUNT, na.rm = TRUE),
                              .groups = 'drop') %>% 
                    mutate(catch = ifelse(weight > 0, weight, count)) %>% 
                    group_by(ACCOUNT_NAME) %>% 
                    mutate(percentage = catch / sum(catch) * 100) %>% 
                    arrange(DISCARD_FLAG, desc(percentage))

f1 <- ggplot(accounts_discard, aes(x = ACCOUNT_NAME, y = percentage, fill = DISCARD_FLAG)) +
      geom_col() +
      scale_x_discrete(limits = unique(accounts_discard$ACCOUNT_NAME[order(desc(accounts_discard$DISCARD_FLAG), desc(accounts_discard$percentage))])) +
      scale_fill_manual(values = kelly()[2:22]) +
      labs(x = "Account Name", y = "Percentage of Catch", fill = "Discard") +
      coord_flip() +
      theme_classic() +
      theme(axis.text.y = element_text(size = 4))

f1
```

It's also helpful to visualize how much catch occurs in partial coverage within each account:  
```{r accounts_coverage}
accounts_coverage <- valhalla %>% 
                     filter(ADP == 2021 & ACCOUNT_NAME != "No Account") %>% 
                     group_by(ACCOUNT_NAME, COVERAGE_TYPE) %>%
                     summarise(weight = sum(WEIGHT_POSTED, na.rm = TRUE),
                               count  = sum(SPECIES_COUNT, na.rm = TRUE),
                               .groups = 'drop') %>% 
                     mutate(catch = ifelse(weight > 0, weight, count)) %>% 
                     group_by(ACCOUNT_NAME) %>% 
                     mutate(percentage = catch / sum(catch) * 100) %>% 
                     arrange(COVERAGE_TYPE, desc(percentage))

f2 <- ggplot(accounts_coverage, aes(x = ACCOUNT_NAME, y = percentage, fill = COVERAGE_TYPE)) +
      geom_col() +
      scale_x_discrete(limits = unique(accounts_coverage$ACCOUNT_NAME[order(desc(accounts_coverage$COVERAGE_TYPE), desc(accounts_coverage$percentage))])) +
      scale_fill_manual(values = kelly()[2:22], labels = c("Full", "Partial")) +
      labs(x = "Account Name", y = "Percentage of Catch", fill = "Coverage Type") +
      coord_flip() +
      theme_classic() +
      theme(axis.text.y = element_text(size = 4))

f2
```

The account names on the y-axes of these plots are not in the same order, however, so it's not necessarily the case that fisheries with high retention fall into full coverage. Let's look at the graphs side by side with the same account order:  
```{r accounts_discard_coverage}
f3 <- ggplot(arrange(accounts_discard, ACCOUNT_NAME), aes(x = ACCOUNT_NAME, y = percentage, fill = DISCARD_FLAG)) +
      geom_col() +
      scale_fill_manual(values = kelly()[2:22]) +
      labs(x = "Account Name", y = "Percentage of Catch", fill = "Discard") +
      coord_flip() +
      theme_classic() +
      theme(axis.text.y = element_text(size = 4), legend.position = "bottom")

f4 <- ggplot(arrange(accounts_coverage, ACCOUNT_NAME), aes(x = ACCOUNT_NAME, y = percentage, fill = COVERAGE_TYPE)) +
      geom_col() +
      scale_fill_manual(values = kelly()[2:22], labels = c("Full", "Partial")) +
      labs(x = "Account Name", y = "Percentage of Catch", fill = "Coverage Type") +
      coord_flip() +
      theme_classic() +
      theme(axis.text.y = element_text(size = 4), legend.position = "bottom")

grid.arrange(f3, f4, ncol = 2)
```

