---
title: "Between-Trip Variance Evaluation Metric"
output: html_document
date: "`r Sys.Date()`"
editor_options: 
  chunk_output_type: console
---

```{r start, include=FALSE}
# Get packages
library(data.table)
library(flextable)
library(tidyverse)

# Get data
load("source_data/2024_Draft_ADP_data.rdata")
rm(list=setdiff(ls(), c("trips_melt", "efrt", "work.data")))

# Settings
knitr::opts_chunk$set(echo = TRUE)
options(scipen = 9999)
```

```{r wrangle}
# Convert optimization metrics to wide format
metrics <- dcast(trips_melt[, .(TRIP_ID, STRATA = strata_ID, METRIC = Metric, VALUE = Value)], TRIP_ID + STRATA ~ METRIC, value.var = "VALUE")

# Join optimization metric values with the most recent year of trips
dat <- metrics[efrt[ADP == 2022], on = .(TRIP_ID, STRATA), nomatch=0]

# Total number of trips per stratum
dat[, N := uniqueN(TRIP_ID), keyby = .(STRATA)]

# Sum metrics by columns of interest
dat <- dat[, .(chnk_psc = sum(chnk_psc), hlbt_psc = sum(hlbt_psc), discard = sum(discard)), by = .(TRIP_ID, STRATA, N)]

# Calculate between-trip standard deviation
dat <- dat[, .(sd_chnk = sd(chnk_psc), sd_hlbt = sd(hlbt_psc), sd_discard = sd(discard)), by = .(STRATA, N)]

# Join with the full range of sample sizes for each stratum  
dat <- dat[, .(n = 2:N), by = .(STRATA)][dat, on = .(STRATA)]

# Convert to long format  
dat <- melt(dat, id.vars = c("STRATA", "n", "N"), variable.name = "metric", value.name = "sd")

# Calculate stratum-level standard error  
dat[, se := N * sqrt((N-n)/N) * sqrt(1/n) * sd]

# Recode strata and metric names
dat[, ":=" (STRATA = recode(STRATA, "EM_HAL" = "EM HAL", "EM_POT" = "EM POT", "EM_TRW_EFP" = "EM TRW EFP"), metric = recode(metric, "sd_chnk" = "Chinook PSC", "sd_hlbt" = "Halibut PSC", "sd_discard" = "Groundfish discards"))]

# Calculate monitoring rate
dat[, monitoring_rate := n/N]
```

```{r plot}
ggplot(dat, aes(x = n, y = se)) +
  geom_line() +
  facet_grid(metric ~ STRATA, scales = "free") +
  theme_bw()
```

If we wanted to see what margins of error would result from two of the allocation schemes proposed in the Draft 2022 ADP (NMFS 2021), we could do so with a table:  
```{r example}
adp_rates <- data.frame(STRATA = c("EM HAL", "EM POT", "EM TRW EFP", "HAL", "POT", "TRW"),
                        equal_rates = c(30.00, 30.00, 33.33, 19.44, 19.44, 19.44),
                        min_plus_opt_0.95 = c(30.00, 30.00, 33.33, 18.21, 17.48, 28.10))

se_adp <- dat %>% 
          left_join(adp_rates, by = "STRATA") 

se_adp <- rbind(
          se_adp %>% 
          group_by(STRATA) %>% 
          filter(round(equal_rates/100 * N) == n) %>% 
          mutate(`Allocation scheme` = "Equal Rates") %>% 
          ungroup(),
          se_adp %>% 
          group_by(STRATA) %>% 
          filter(round(min_plus_opt_0.95/100 * N) == n) %>% 
          mutate(`Allocation scheme` = "15% + Opt 0.95") %>% 
          ungroup())

se_adp <- se_adp %>% 
          mutate(margin_of_error = 1.96 * se) %>% 
          select(STRATA, Metric = metric, `Allocation scheme`, margin_of_error)

se_adp <- reshape2::dcast(se_adp, `Allocation scheme` + Metric ~ STRATA, value.var = "margin_of_error")

se_adp <- se_adp %>% 
          mutate(Total = rowSums(select_if(., is.numeric), na.rm = TRUE)) %>% 
          mutate_if(is.numeric, round) %>% 
          arrange(Metric, `Allocation scheme`) 

ft_se_adp <- flextable(se_adp)

ft_se_adp %>% width(j = c(1,2), width = 1.5)
```

