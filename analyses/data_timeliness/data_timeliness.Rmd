---
title: "Data Timeliness as an Evaluation Metric"
output: html_document
date: "`r Sys.Date()`"
editor_options: 
  chunk_output_type: console
---

```{r start, include=FALSE}
library(data.table)
library(reshape2)
library(ROracle)
library(tidyverse)

channel_akro <- eval(parse(text = Sys.getenv("channel_cas")))
channel_afsc <- eval(parse(text = Sys.getenv("channel_afsc")))

knitr::opts_chunk$set(echo = FALSE)
options(scipen = 9999)
```

```{r get_data}
em_trip_end <- dbGetQuery(channel_afsc, "
select distinct e.year, e.odds_trip_number,
trunc(max(t.trip_end_date_time)) as trip_end
from norpac.odds_logged_trip_summary_v e
join norpac.odds_em_request_status h on h.status_year = e.year 
join norpac.odds_monitor i on i.trip_plan_log_seq = e.odds_trip_number
left join em_pac_review.em_trip t on t.trip_plan_log_seq = e.odds_trip_number
where e.year = 2022
and e.observer_status_code <> 'NO'
and e.trip_status in ('COMPLETED', 'PENDING')
and i.sample_plan_seq in (13)
group by e.year, e.odds_trip_number
order by e.odds_trip_number")

em_data_available <- dbGetQuery(channel_akro, "
select h.ODDS_TRIP_NUMBER, 
-- sampling strata information
case when ss.sampling_strata_code in ('F', 'EM_TrawlFullCoverage') then 'FULL' else 'PARTIAL' end as coverage_type,
decode(ss.sampling_strata_code,
'EM_H', 'EM_HAL',
'EM_P', 'EM_POT',
'H'   , 'EM_HAL',
'P'   , 'EM_POT') as strata,
trunc(min(r.EFFECTIVE_DATE)) data_available
from AKFISH_REPORT.CATCH_REPORT_SOURCE r
join AKFISH_REPORT.CATCH_REPORT_SPECIES_FACT f on r.CATCH_REPORT_SOURCE_PK = f.CATCH_REPORT_SOURCE_PK
join AKFISH_REPORT.EM_HAUL h on f.EM_HAUL_PK = h.EM_HAUL_PK
join AKFISH_REPORT.CALENDAR_DATE c on f.REPORT_DATE_PK = c.CALENDAR_DATE_PK
join akfish_report.sampling_strata ss on ss.sampling_strata_pk = f.sampling_strata_pk
where r.year_pk >= 2021 
and r.CATCH_REPORT_TYPE_CODE = 'EM'
and ss.sampling_strata_code != 'N/A'
group by h.ODDS_TRIP_NUMBER,
case when ss.sampling_strata_code in ('F', 'EM_TrawlFullCoverage') then 'FULL' else 'PARTIAL' end,
decode(ss.sampling_strata_code,
'EM_H', 'EM_HAL',
'EM_P', 'EM_POT',
'H'   , 'EM_HAL',
'P'   , 'EM_POT')
order by h.ODDS_TRIP_NUMBER")

ob_trips <- dbGetQuery(channel_afsc, 
  "select extract(year from t.start_date) as year, t.cruise, t.permit, t.trip_seq, t.end_date as trip_end
   from norpac.atl_fma_trip t
   join norpac.ols_observer_cruise cru on cru.cruise = t.cruise
   join norpac.ols_observer_contract con on con.contract_number = cru.contract_number
   where extract(year from t.start_date) = 2022
   and t.did_fishing_occur_flag = 'Y'")

ob_hauls <- dbGetQuery(channel_akro, 
  "select h.cruise, to_char(v.vessel_id) as permit, h.trip_seq,
  -- sampling strata information
case when ss.sampling_strata_code in ('F', 'EM_TrawlFullCoverage') then 'FULL' else 'PARTIAL' end as coverage_type,
decode(ss.sampling_strata_code,
'EM_H', 'EM_HAL',
'EM_P', 'EM_POT',
'EM_TrawlFullCoverage', 'EM_TRW_EFP',
'EM_TrawlPartialCoverage', 'EM_TRW_EFP',
'EM_TrawlPartialCoverageTen', 'EM_TRW_EFP',
'F', 'FULL',
'H', 'HAL',
'N', 'ZERO',
'P', 'POT',
'TR', 'TRW') as strata,
trunc(min(r.EFFECTIVE_DATE)) data_available
from AKFISH_REPORT.CATCH_REPORT_SOURCE r
join AKFISH_REPORT.CATCH_REPORT_SPECIES_FACT f on r.CATCH_REPORT_SOURCE_PK = f.CATCH_REPORT_SOURCE_PK
join AKFISH_REPORT.OBSERVER_HAUL h on f.OBSERVER_HAUL_PK = h.OBSERVER_HAUL_PK
join AKFISH_REPORT.CALENDAR_DATE c on f.REPORT_DATE_PK = c.CALENDAR_DATE_PK
join akfish_report.sampling_strata ss on ss.sampling_strata_pk = f.sampling_strata_pk
join akfish_report.vessel v on v.vessel_pk = f.vessel_pk
where r.year_pk >= 2021 
and r.CATCH_REPORT_TYPE_CODE = 'OBS'
and ss.sampling_strata_code != 'N/A'
group by h.cruise, v.vessel_id, h.trip_seq,
case when ss.sampling_strata_code in ('F', 'EM_TrawlFullCoverage') then 'FULL' else 'PARTIAL' end,
decode(ss.sampling_strata_code,
'EM_H', 'EM_HAL',
'EM_P', 'EM_POT',
'EM_TrawlFullCoverage', 'EM_TRW_EFP',
'EM_TrawlPartialCoverage', 'EM_TRW_EFP',
'EM_TrawlPartialCoverageTen', 'EM_TRW_EFP',
'F', 'FULL',
'H', 'HAL',
'N', 'ZERO',
'P', 'POT',
'TR', 'TRW')")

afsc_offloads <- dbGetQuery(channel_afsc, 
"select distinct extract(year from delivery_end_date) as year, landing_report_id, delivery_end_date
from norpac.atl_offload
where extract(year from delivery_end_date) = 2022")

akro_offloads <- dbGetQuery(channel_akro, 
"select r.el_report_id as landing_report_id,
-- sampling strata information
case when ss.sampling_strata_code in ('F', 'EM_TrawlFullCoverage') then 'FULL' else 'PARTIAL' end as coverage_type,
decode(ss.sampling_strata_code,
'EM_TrawlFullCoverage', 'EM_TRW_EFP',
'EM_TrawlPartialCoverage', 'EM_TRW_EFP',
'EM_TrawlPartialCoverageTen', 'EM_TRW_EFP') as strata,
trunc(min(r.EFFECTIVE_DATE)) data_available
from AKFISH_REPORT.CATCH_REPORT_SOURCE r
join AKFISH_REPORT.CATCH_REPORT_SPECIES_FACT f on r.CATCH_REPORT_SOURCE_PK = f.CATCH_REPORT_SOURCE_PK
join AKFISH_REPORT.OBSERVER_OFFLOAD o on f.OBSERVER_OFFLOAD_PK = o.OBSERVER_OFFLOAD_PK
join AKFISH_REPORT.CALENDAR_DATE c on f.REPORT_DATE_PK = c.CALENDAR_DATE_PK
join akfish_report.sampling_strata ss on ss.sampling_strata_pk = f.sampling_strata_pk
join akfish_report.vessel v on v.vessel_pk = f.vessel_pk
where r.year_pk >= 2021 
and r.CATCH_REPORT_TYPE_CODE = 'EM_OFFLOAD'
and ss.sampling_strata_code in ('EM_TrawlFullCoverage', 'EM_TrawlPartialCoverage', 'EM_TrawlPartialCoverageTen')
group by r.el_report_id,
case when ss.sampling_strata_code in ('F', 'EM_TrawlFullCoverage') then 'FULL' else 'PARTIAL' end,
decode(ss.sampling_strata_code,
'EM_TrawlFullCoverage', 'EM_TRW_EFP',
'EM_TrawlPartialCoverage', 'EM_TRW_EFP',
'EM_TrawlPartialCoverageTen', 'EM_TRW_EFP')")
```

```{r wrangle_data}
em_data_timeliness <- em_trip_end %>% 
                      left_join(
                      em_data_available, 
                      by = "ODDS_TRIP_NUMBER"
                      ) %>% 
                      # TODO: decide how to handle trips that have no end date
                      filter(!is.na(TRIP_END)) %>% 
                      # TODO: decide how to handle trips that weren't reviewed
                      filter(!is.na(DATA_AVAILABLE)) %>%
                      select(YEAR, TRIP_NUMBER = ODDS_TRIP_NUMBER, COVERAGE_TYPE, STRATA, TRIP_END, DATA_AVAILABLE) %>% 
                      mutate(TRIP_END = as.Date(TRIP_END),
                             DATA_AVAILABLE = as.Date(DATA_AVAILABLE),
                             data_timeliness = as.numeric(difftime(DATA_AVAILABLE, TRIP_END, units = "days")))
                      
ob_data_timeliness <- ob_trips %>% 
                      inner_join(
                      ob_hauls,
                      by = c("CRUISE", "PERMIT", "TRIP_SEQ")
                      ) %>% 
                      # TODO: decide how to handle trips that have no end date
                      filter(!is.na(TRIP_END)) %>% 
                      mutate(TRIP_NUMBER = paste0(CRUISE, PERMIT, TRIP_SEQ), 
                             TRIP_END = as.Date(TRIP_END),
                             DATA_AVAILABLE = as.Date(DATA_AVAILABLE)) %>% 
                      select(YEAR, TRIP_NUMBER, COVERAGE_TYPE, STRATA, TRIP_END, DATA_AVAILABLE) %>%  
                      mutate(data_timeliness = as.numeric(difftime(DATA_AVAILABLE, TRIP_END, units = "days")))

offload_data_timeliness <- afsc_offloads %>% 
                           left_join(
                           akro_offloads, 
                           by = "LANDING_REPORT_ID"
                           ) %>% 
                           # TODO: decide how to handle trips that have no end date
                           filter(!is.na(LANDING_REPORT_ID)) %>% 
                           # TODO: decide how to handle trips that weren't reviewed
                           filter(!is.na(DATA_AVAILABLE)) %>% 
                           select(YEAR, TRIP_NUMBER = LANDING_REPORT_ID, COVERAGE_TYPE, STRATA, TRIP_END = DELIVERY_END_DATE, DATA_AVAILABLE) %>% 
                           mutate(TRIP_END = as.Date(TRIP_END),
                                  DATA_AVAILABLE = as.Date(DATA_AVAILABLE),
                                  data_timeliness = as.numeric(difftime(DATA_AVAILABLE, TRIP_END, units = "days")))

data_timeliness <- rbind(em_data_timeliness, ob_data_timeliness, offload_data_timeliness) %>% 
                   mutate(data_timeliness = ifelse(data_timeliness < 0, 0, data_timeliness))
```

# Calculating Data Timeliness
Data timeliness was calculated as the time between a trip ending and data being available to the Catch Accounting System. We used the time at which data were available to the CAS, rather than the time at which data were submitted to the AFSC, as the former could be measured more consistently across EM and observed strata. Data from 2022 were used to calculate strata-specific data timeliness.  
```{r figure}
times_smry <- data_timeliness %>%
              group_by(YEAR, COVERAGE_TYPE, STRATA) %>%
              summarise('25th percentile' = round(as.vector(quantile(data_timeliness, 0.25)), 2),
                        median = round(as.vector(quantile(data_timeliness, 0.50)), 2),
                        '75th percentile' = round(as.vector(quantile(data_timeliness, 0.75)), 2),
                        mean = round(mean(data_timeliness), 2), .groups = "drop") %>%
              melt(id.vars=c("YEAR", "COVERAGE_TYPE", "STRATA"), measure.vars=c("25th percentile", "median", "75th percentile", "mean")) %>%
              mutate(label = format(value, nsmall = 2))

times_figure <- ggplot(data_timeliness, aes(x=data_timeliness)) +
                facet_grid(STRATA ~ YEAR + COVERAGE_TYPE, scales="free_y") +
                geom_histogram(bins=20, fill="gray70") +
                geom_vline(data = filter(times_smry, variable == "mean"), aes(xintercept=value), linetype=2) +
                geom_text(data = filter(times_smry, variable == "mean"), aes(x=value, y=Inf, label=paste(variable, label, sep = ": ")), angle=90, hjust=1.1, vjust=-.25) +
                labs(x="Data timeliness (days)", y="Count") +
                theme_bw() +
                theme(text=element_text(size=20))

times_figure

if(!file.exists("output_figures/data_timeliness.png")){
  ggsave(filename = "output_figures/data_timeliness.png", width = 9, height = 14, units = 'in')}
```

# Creating a Function
Stratum-specific mean data timeliness was then embedded in a function that will
```{r table}
strata_timeliness <- times_smry %>% 
                     filter(variable == "mean") %>% 
                     select(COVERAGE_TYPE, STRATA, data_timeliness = value)

val <- dbGetQuery(channel_akro, "select * from akfish_sf.valhalla where adp = 2022")

data       <- setDT(val)
strata     <- setDT(strata_timeliness)

evaluate_data_timeliness <- function(data, strata_timeliness){

dt <- strata_timeliness[data, on = .(COVERAGE_TYPE, STRATA)]
dt <- unique(dt[, .(TRIP_ID, COVERAGE_TYPE, STRATA, data_timeliness)])

if(nrow(dt[is.na(data_timeliness)]) > 1){
  warning("NAs detected in data timeliness detected.")
}
  
return(round(mean(dt$data_timeliness, na.rm = TRUE), 2))  
}

evaluate_data_timeliness(data, strata)
```

