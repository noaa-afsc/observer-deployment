# Script for spatiotemporal_boxes_analysis.Rmd

#==================#
# Load Packages ####
#==================#

library(data.table)         # Data wrangling
library(ggplot2)            # Plotting
library(flextable)          # Cleaner tables for Rmarkdown
library(sf)                 # Spatial analyses
library(dplyr)              # Data wrangling sf objects
library(flextable)          # Print-ready tables
library(officer)            # Additional options for flextable
library(lmerTest)           # For mixed-effects modeling
library(ggrepel)            # For repelled text labels in plots

#===================#
# Load Functions ####
#===================#

source("analyses/spatiotemporal_boxes/stat_area_to_hex_fun.R")         # Creates hex grids
source("analyses/spatiotemporal_boxes/define_post_stratum_fun.R")      # Applies box definitions

# New functions

# TODO should be able to use this in mean_prop_n as well?
# Quickly counts the number of trips per box
count_trips_per_cell <- function(x) {
  rbindlist(
    lapply(x, function(y) as.data.table(y)[, .(CELL_N = uniqueN(TRIP_ID)), by = PS_ID]), 
    idcol = "ADP.STRATA")
}

# Calculates the expected proportion of trips sampled or near a sampled neighbor in a stratum x year
calculate_mean_prop_n <- function(ps_res, sample_rate_vec) {
  # Collapse PS total weights into a dt.
  # FIXME relies on adp_strata_N_dt being in the global environment!

  ps_w_dt <- rbindlist(
    lapply(ps_res$W, as.data.table),
    idcol = "ADP.STRATA"
  )[, c("ADP", "STRATA") := tstrsplit(ADP.STRATA, split = "[.]")
  ][, ADP := as.integer(ADP)
  ][, ADP.STRATA := NULL]
  
  # Count trips in post-strata, combine with weights and STRATA N
  ps_smry_dt <- ps_res$dt[, .(n = length(unique(TRIP_ID))), keyby=.(ADP, STRATA, PS_ID)]
  ps_smry_dt[, N := adp_strata_N_dt[ps_smry_dt, N, on = .(ADP, STRATA)]]
  ps_smry_dt[, W := ps_w_dt[ps_smry_dt, W, on = .(ADP, STRATA, PS_ID)]]
  
  # For for a range of sample rates, calculate the probably that a post-stratum would be near a sampled neighbor
  # (0-1), and then multiply it by that post-stratum's total weight of component trips centered on the post-stratum.
  
  ps_prop_n <- lapply(
    sample_rate_vec,
    # For each sample rate 'x'...
    ps_prop_n_lst <- function(x) {
      x1 <- copy(ps_smry_dt)
      x1[, p := 1 - ((1 - x)^n)]   # Calculate the probability that the post-stratum will be near a sampled neighbor
      x1[, .(sum_W_p = sum(W * p)), by = .(ADP, STRATA, N)][   # Multiply the probability by the weight (number of component trips centered in the box)
      ][, MEAN_PROP_N_IN_SAMPLED_PS := sum_W_p / N][]
    }
  )
  names(ps_prop_n) <- sample_rate_vec
  ps_prop_n <- rbindlist(ps_prop_n, idcol = "SAMPLE_RATE")[, SAMPLE_RATE := as.numeric(SAMPLE_RATE)][]
  ps_prop_n
}

# Creates a table of summary statistics for a given box definition
box_smry_flex <- function(x) {
  x1 <- x[, .(
    BOX_COUNT = .N, MEAN_TPB = mean(CELL_N), MEDIAN_TPB = as.integer(median(CELL_N)), 
    Q_25 = as.integer(quantile(CELL_N, 0.25)), P_3 = sum(CELL_N <= 3) / .N), 
    by = .(STRATA, ADP)]  # 10% of boxes have 3 or fewer trips!
  x2 <- dcast(x1, STRATA ~ ADP, value.var = c("BOX_COUNT", "MEAN_TPB", "MEDIAN_TPB", "Q_25", "P_3"), sep = ".")
  flextable(x2) %>% 
    separate_header(split = "[.]") %>% colformat_double(digits = 2)  %>% 
    vline(j = c(1, 5, 9, 13, 17), border = fp_border(style = "dashed")) %>% autofit()
}

#==============#
# Data Prep ####
#==============#

# Fishing effort data from 2018 to 2021
# `spatiotemporal_boxes.rdata' is generated by /analyses/spatiotemporal_boxes/data_prep.R
load("analyses/spatiotemporal_boxes/spatiotemporal_boxes.RData")

# Load the ADFG statistical area shapefile. '../' is needed for Rmarkdown to climb into parent folders.
stat_area_sf <- st_read(
  dsn = "source_data/ADFG_Stat_Area_shapefile/PVG_Statewide_2001_Present_GCS_WGS1984.shp", quiet = T) %>%
  select(STAT_AREA) %>%
  st_transform(crs = 3467)

# Load the Alaska map sf objects
load("source_data/ak_shp.rdata")      # shp_land, shp_nmfs, and shp_centroids added to global

# Simplify the dataset
effort <- unique(val_2018_2021_dt[
][STRATA != "ZERO" 
][, .(ADP, STRATA, ADFG_STAT_AREA_CODE, WEEK, GEAR, TRIP_ID)
][ADFG_STAT_AREA_CODE == 515832, ADFG_STAT_AREA_CODE := 515831        # 515832 is missing from shape file
][, TRIP_ID := .GRP, by = .(TRIP_ID)])

# Make another form the dataset that groups by MONTH instead of WEEK
effort_month <- copy(effort)
week_to_month_dt <- data.table(WEEK = 1:53)[
][, MONTH := cut(WEEK, breaks = round((.N/12) * 0:12), labels = F)]
effort_month[, MONTH := week_to_month_dt[effort_month, MONTH, on = .(WEEK)]]

# Count number of trips per stratum per year
adp_strata_N_dt <- effort[, .(N = uniqueN(TRIP_ID)), keyby = .(ADP, STRATA)]


#===================================#
# SPECIFY RANGES OF BOX DEFINITIONS #
#===================================#

# SPATIAL #
cell_size_vector <- seq(1.0e5, 7.5e5, by = 2.5e4)  # For space, cell size affects both cell size and search radius
# Can either do no overlap (0), 1x cell size, or 2x cell size.
space_lst <- asplit(as.matrix(setNames(expand.grid(cell_size_vector, 0:2 ), c("cell_size", "radius_factor"))), 1)
# Set a range of monitoring rates to calculate MEAN_PROP_N for 
sample_rate_vec <- seq(from = 0.005, to = 0.800, by = 0.0025)          

# Quick-load the results below
if(F) {
  # For each spatial definition, combine with a temporal definition
  time_space_check_lst <- lapply(
    space_lst,
    function(x) {
      
      cat(x, "\n")
      
      # Week
      week_0 <- define_poststrata_fun(effort, space = c(x[[1]], x[[1]] * x[[2]]), time = c("WEEK", 0), year_strata = c("ADP", "STRATA"))
      week_1 <- define_poststrata_fun(effort, space = c(x[[1]], x[[1]] * x[[2]]), time = c("WEEK", 1), year_strata = c("ADP", "STRATA"))
      week_2 <- define_poststrata_fun(effort, space = c(x[[1]], x[[1]] * x[[2]]), time = c("WEEK", 2), year_strata = c("ADP", "STRATA"))
      
      # Month
      month_0 <- define_poststrata_fun(effort_month, space = c(x[[1]], x[[1]] * x[[2]]), time = c("MONTH", 0), year_strata = c("ADP", "STRATA"))
      month_1 <- define_poststrata_fun(effort_month, space = c(x[[1]], x[[1]] * x[[2]]), time = c("MONTH", 1), year_strata = c("ADP", "STRATA"))
      month_2 <- define_poststrata_fun(effort_month, space = c(x[[1]], x[[1]] * x[[2]]), time = c("MONTH", 2), year_strata = c("ADP", "STRATA"))
      
      # Combine the trip per cell counts
      trips_per_cell_dt <- rbind(
        cbind(TIME = "WEEK", TIME_OVER = 0, count_trips_per_cell(week_0$ps_trip_id)),
        cbind(TIME = "WEEK", TIME_OVER = 1, count_trips_per_cell(week_1$ps_trip_id)),
        cbind(TIME = "WEEK", TIME_OVER = 2, count_trips_per_cell(week_2$ps_trip_id)),
        cbind(TIME = "MONTH", TIME_OVER = 0, count_trips_per_cell(month_0$ps_trip_id)),
        cbind(TIME = "MONTH", TIME_OVER = 1, count_trips_per_cell(month_1$ps_trip_id)),
        cbind(TIME = "MONTH", TIME_OVER = 2, count_trips_per_cell(month_2$ps_trip_id))
      )
      
      # For each definition, also apply a range of monitoring rates to calculate the MEAN_PROP_N index,
      # or the average proportion of trips in stratum that are either in a sampled cell (or near a sampled neighbor, if 
      # the definition has overlapping cells)
      if(F) {
        mean_prop_n_dt <- rbind(
          cbind(TIME = "WEEK",  TIME_OVER = 0, calculate_mean_prop_n(week_0,  sample_rate_vec)),
          cbind(TIME = "WEEK",  TIME_OVER = 1, calculate_mean_prop_n(week_1,  sample_rate_vec)),
          cbind(TIME = "WEEK",  TIME_OVER = 2, calculate_mean_prop_n(week_2,  sample_rate_vec)),
          cbind(TIME = "MONTH", TIME_OVER = 0, calculate_mean_prop_n(month_0, sample_rate_vec)),
          cbind(TIME = "MONTH", TIME_OVER = 1, calculate_mean_prop_n(month_1, sample_rate_vec)),
          cbind(TIME = "MONTH", TIME_OVER = 2, calculate_mean_prop_n(month_2, sample_rate_vec))
        )
      }
      
      # return as a list of trips_per_cell and mean_prop_n
      return(
        list(
          TRIPS_PER_CELL = trips_per_cell_dt #, 
          #MEAN_PROP_N = mean_prop_n_dt
        )
      )
    }
  )
  
  time_space_check_TPC_dt <- rbindlist(Map(function(m1, m2) cbind(m1, cell_size = m2[1], radius = m2[2]), m1 = lapply(time_space_check_lst, "[[", "TRIPS_PER_CELL"), m2 = space_lst))
  # save(time_space_check_TPC_dt, file = "analyses/spatiotemporal_boxes/sea_design_exploration_2.RData")
  
  #time_space_check_MPN_dt <- rbindlist(Map(function(m1, m2) cbind(m1, cell_size = m2[1], radius = m2[2]), m1 = lapply(time_space_check_lst, "[[", "MEAN_PROP_N"), m2 = space_lst))
  #  save(time_space_check_TPC_dt, time_space_check_MPN_dt, file = "analyses/spatiotemporal_boxes/sea_design_exploration_2.RData")
  
}

load("analyses/spatiotemporal_boxes/sea_design_exploration_2.RData")

time_space_check_TPC_dt[, c("ADP", "STRATA") := tstrsplit(ADP.STRATA, split = "[.]")]
time_space_check_TPC_dt[, PS_DEF := .GRP, by = .(TIME, TIME_OVER, cell_size, radius)]

#================================#
# MAP OF NMFS AREAS AND GRIDS ####
#================================#

grid_250km <- stat_area_to_hex_fun(2.5e5, stat_area_sf)
grid_750km <- stat_area_to_hex_fun(7.5e5, stat_area_sf)

# Summarize non-zero fishing effort in PC with 100km cells
grid_100km <- stat_area_to_hex_fun(1e5, stat_area_sf)
effort_100km <- unique(merge(effort[ADP == 2021], grid_100km$STAT_AREA_HEX_DF, by = "ADFG_STAT_AREA_CODE")[, .(TRIP_ID, HEX_ID)])
effort_100km_cell_counts <- effort_100km[, .(TRIP_N = uniqueN(TRIP_ID)), by = .(HEX_ID)]
effort_100km_cell_counts <- merge(grid_100km$HEX_GEOMETRY, effort_100km_cell_counts, by = "HEX_ID")

ak_map <- ggplot() + 
  geom_sf(data = shp_nmfs, fill = NA, color = "red") + 
  geom_sf(data = shp_land, fill = "gray") + 
  geom_sf(data = effort_100km_cell_counts, aes(fill = TRIP_N), color = NA, alpha = 0.8) +
  geom_sf(data = grid_250km$HEX_GEOMETRY, fill = NA, color = "blue") + 
  geom_sf(data = grid_750km$HEX_GEOMETRY, fill = NA, color = "forest green") + 
  scale_fill_viridis_c(trans = "log", breaks = c(1, 5, 10, 25, 50)) +
  labs(fill = "Trip Counts") + 
  theme(legend.position = "bottom", axis.title = element_blank())

#=======================#
# Summary Statistics ####
#=======================#

# Need to define box size for allocation schemes that use the probability that a trip is sampled or near a sampled 
# neighbor to more heavily allocate towards strata that have boxes. Look at a variety of summary statistics to see
# how the distribution of the number of trips per box varies with different box definitions.

# first, check the extreme ranges, with the smallest boxes first, no overlap, nothing but gaps!
box_smry_flex_tiny <-  box_smry_flex(time_space_check_TPC_dt[(cell_size == 1e5 & TIME == "WEEK" & TIME_OVER == 0 & radius == 0)])
# Way too many small boxes. Most strata have a majority of boxes with 3 or fewer trips. Not useful.

# Largest with insane levels of overlap, virtually no gaps!
box_smry_flex_huge <- box_smry_flex(time_space_check_TPC_dt[(cell_size == 7.5e5 & TIME == "MONTH" & TIME_OVER == 2 & radius == 2)])
# Same number of boxes as before, we just let them overlap to huge spatial and temporal extents.
# All strata have virtually 0 P_3. Basically impossible to have a gap at this definition. Makes this definition useless.

# What cell size is approximately similar to a NMFS area?
mean(st_area(shp_nmfs)) / 1e6  # Mean NMFS AREA extent with area of 137732 km2
cell_size_dt <- data.table(cell_size = cell_size_vector)
cell_size_dt[, AREA := (3 * sqrt(3) / 2) * (cell_size/sqrt(3))^2 / 1e6]  # calculate area of hexagon using distance between two parallel sides
cell_size_dt[data.table(AREA = 137732), on = .(AREA), roll = "nearest"]  # A cell size of 400km is about the size of a NMFS area (Area of 137732 m2)
box_smry_flex_cas <- box_smry_flex(time_space_check_TPC_dt[(cell_size == 4e5 & TIME == "WEEK" & TIME_OVER == 2 & radius == 0)])

# Look at P_3 across all box definitions
ps_def_p_3 <- time_space_check_TPC_dt[
][, .(P_3 = sum(CELL_N <= 3)/.N) , by = .(ADP, STRATA, PS_DEF, TIME, TIME_OVER, cell_size, radius)
][, .(MEAN_P3 = mean(P_3)), by = .(PS_DEF, TIME, TIME_OVER, cell_size, radius)]
hist(ps_def_p_3$MEAN_P3, breaks = 30); abline(v = c(0.01, 0.1), col = "red")
ps_def_p_3[, TIME := factor(TIME, levels = c("WEEK", "MONTH"))]
p3_plot <- ggplot(ps_def_p_3, aes(x = TIME, y = cell_size/1e3, fill = MEAN_P3, label = formatC(MEAN_P3, digits = 3, format = "f"))) + geom_tile() + 
  geom_text(size = 3) + 
  facet_grid(radius ~ TIME_OVER, labeller = labeller(TIME_OVER = function(x) paste("Time Overlap:", x), radius = function(x) paste("Radius:", x) )) + 
  scale_fill_viridis_c() + theme(legend.position = "bottom") + labs(x = "Time Unit", y = "Cell size (km)", fill = "Mean P_3")

ps_def_p_3[, FILL := factor(fcase(MEAN_P3 < 0.01, "< 0.01", MEAN_P3 > 0.2, "> 0.2", default = "Good"), levels = c("< 0.01", "Good", "> 0.2"))]

# With PS_DEF included
ggplot(ps_def_p_3, aes(x = TIME, y = cell_size, fill = FILL, label = paste0(PS_DEF, " : ", formatC(MEAN_P3, digits =3, format = "f")))) + geom_tile() + 
  geom_text(size = 3) + 
  facet_grid(TIME_OVER ~ radius, labeller = labeller(TIME_OVER = function(x) paste("Time Overlap:", x), radius = function(x) paste("Radius:", x) )) + 
  theme(legend.position = "bottom") + labs(x = "Time Unit", y = "Cell size (km)", fill = "Mean P_3") + 
  scale_fill_viridis_d()

p3_plot_select <- ggplot(ps_def_p_3, aes(x = TIME, y = cell_size/1e3, fill = FILL, label = formatC(MEAN_P3, digits =3, format = "f"))) + geom_tile() + 
  geom_text(size = 3) + 
  facet_grid(radius ~ TIME_OVER, labeller = labeller(TIME_OVER = function(x) paste("Time Overlap:", x), radius = function(x) paste("Radius:", x) )) + 
  theme(legend.position = "bottom") + labs(x = "Time Unit", y = "Cell size (km)", fill = "Mean P_3") + 
  scale_fill_viridis_d()

keep_ps_def <- ps_def_p_3[FILL == "Good", PS_DEF]
length(keep_ps_def) / uniqueN(ps_def_p_3$PS_DEF)
# Looking at p3_plot_select, exclude borderline cases
keep_ps_def <- setdiff(keep_ps_def, c(319, 263, 367, 405))

#============================#
# Relating space and time ####
#============================#

# Calcaalte extent of space and time in units of area and days, respectively.
st_compare <- copy(time_space_check_TPC_dt)
st_compare[, CELL_AREA_km2 := (3 * sqrt(3) / 2) * (cell_size/sqrt(3))^2 / 1e6]                       # area of cell_size alone
st_compare[, CELL_EXTENT_km2 := CELL_AREA_km2 * fcase(radius==0, 1, radius==1, 7, radius==2, 19)]     # area of extent including neighbors (using radius)
st_compare[, ADP := as.integer(ADP)]
st_compare[, N := adp_strata_N_dt[st_compare, N, on = .(ADP, STRATA)]]    # Merge in stratum trip counts
st_compare[, PROP_N_IN_CELL := CELL_N / N]
st_compare[, DAYS := fcase(
  TIME == "WEEK" & TIME_OVER == 0, 7,
  TIME == "WEEK" & TIME_OVER == 1, 21,
  TIME == "WEEK" & TIME_OVER == 2, 35,
  TIME == "MONTH" & TIME_OVER == 0, 30,
  TIME == "MONTH" & TIME_OVER == 1, 90,
  TIME == "MONTH" & TIME_OVER == 2, 150
)]

# Calculate MEAN_PROP_N_IN_CELL for each PS_DEF, STRATA, and ADP
st_compare_smry <- st_compare[, .(MEAN_PROP_N_IN_CELL = mean(PROP_N_IN_CELL)), by = .(ADP, STRATA, PS_DEF, cell_size, radius, TIME, TIME_OVER, CELL_EXTENT_km2, DAYS)]

# Graph these relationships

# TODO Add mean proportion of trips per cell to metrics table above? Include STRATA_N as well? Will likely need to resize text (already bigger than main text) and remove other metrics (like Q25)

# Space
relate_space_plot <- ggplot(st_compare_smry, aes(x = CELL_EXTENT_km2, y = MEAN_PROP_N_IN_CELL, color = DAYS, group = interaction(DAYS, STRATA,ADP))) +
  geom_line() + scale_color_viridis_c() + labs(x = "Spatial extent of cell in km2", y = "Mean proportion of trips per cell", color = "Days") + 
  theme(legend.position = "bottom", legend.key.width = unit(1.5, "cm"))

# Averaging over ADP and STRATA, so each PS_DEF is a single line
ggplot(st_compare_smry[, .(MEAN_PROP_N_IN_CELL = mean(MEAN_PROP_N_IN_CELL)), by = .(CELL_EXTENT_km2, DAYS)], aes(x = CELL_EXTENT_km2, y = MEAN_PROP_N_IN_CELL, color = DAYS, group = DAYS)) +
  geom_line(size = 1.5) + scale_color_viridis_c() + labs(x = "Spatial extent of cell in km2", y = "Mean proportion of trips per cell", color = "Days") + 
  scale_x_sqrt() + 
  theme(legend.position = "bottom")

# Looks logarithmically related
s_mod <- lmer(MEAN_PROP_N_IN_CELL ~ log(CELL_EXTENT_km2) + (1|STRATA) + (1|ADP), data = st_compare_smry)
range(st_compare_smry$CELL_EXTENT_km2)
s_mod_fit <- data.table(CELL_EXTENT_km2 = seq(1e4, 1e7, 1e4))
s_mod_fit[, MEAN_PROP_N_IN_CELL := predict(s_mod, newdata = s_mod_fit, re.form = ~0)]

# Pick from goldilocks zone, not above 400:1 AREA and 36 days TIME
st_compare_smry[cell_size == 4e5 & radius == 1] # 969,948.5, so roughly 1e6km2
dat_sub <- st_compare_smry[CELL_EXTENT_km2 < 1e6 & DAYS < 36]
s_mod2 <- lmer(MEAN_PROP_N_IN_CELL ~ log(CELL_EXTENT_km2) + (1|STRATA) + (1|ADP), data = dat_sub)
s_mod_fit2 <- data.table(CELL_EXTENT_km2 = seq(1e4, 1e6, 1e4))
s_mod_fit2[, MEAN_PROP_N_IN_CELL := predict(s_mod2, newdata = s_mod_fit2, re.form = ~0)]

relate_space_plot_fit <- ggplot(st_compare_smry, aes(x = CELL_EXTENT_km2, y = MEAN_PROP_N_IN_CELL)) +
  geom_line(aes( color = DAYS, group = interaction(DAYS, STRATA,ADP))) + scale_color_viridis_c() + labs(x = "Spatial extent of cell in km2", y = "Mean proportion of trips per cell", color = "Days") + 
  theme(legend.position = "bottom", legend.key.width = unit(1.5, "cm")) + 
  geom_line(data = s_mod_fit, color = "red", size = 2)

# Using smaller subset
ggplot(dat_sub, aes(x = CELL_EXTENT_km2, y = MEAN_PROP_N_IN_CELL)) +
  geom_line(aes( color = DAYS, group = interaction(DAYS, STRATA,ADP))) + scale_color_viridis_c() + labs(x = "Spatial extent of cell in km2", y = "Mean proportion of trips per cell", color = "Days") + 
  theme(legend.position = "bottom", legend.key.width = unit(1.5, "cm")) + 
  geom_line(data = s_mod_fit2, color = "red", size = 2)

# Time
relate_time_plot <- ggplot(st_compare_smry, aes(x = DAYS, y = MEAN_PROP_N_IN_CELL, color = CELL_EXTENT_km2, group = interaction(CELL_EXTENT_km2, STRATA,ADP))) +
  geom_line() + scale_color_viridis_c() + labs(x = "Temporal extent of cell in days", y = "Mean proportion of trips per cell", color = "Area (km2)") + 
  theme(legend.position = "bottom", legend.key.width = unit(1.5, "cm"))

# Average STRATA and ADP within each cell extent
ggplot(st_compare_smry[, .(MEAN_PROP_N_IN_CELL = mean(MEAN_PROP_N_IN_CELL)), by = .(CELL_EXTENT_km2, DAYS)], aes(x = DAYS, y = MEAN_PROP_N_IN_CELL, color = CELL_EXTENT_km2, group = interaction(CELL_EXTENT_km2))) +
  geom_line() + geom_point() + scale_color_viridis_c() + labs(x = "Temporal extent of cell in days", y = "Mean proportion of trips per cell", color = "Area (km2)") + 
  theme(legend.position = "bottom", legend.key.width = unit(1.5, "cm"))

# Again, logarithmically related
t_mod <- lmer(MEAN_PROP_N_IN_CELL ~ log(DAYS) + (1|STRATA) + (1|ADP), data = st_compare_smry)
range(st_compare_smry$DAYS)
t_mod_fit <- data.table(DAYS = 7:150)
t_mod_fit[, MEAN_PROP_N_IN_CELL := predict(t_mod, newdata = t_mod_fit, re.form = ~0)]

t_mod2 <- lmer(MEAN_PROP_N_IN_CELL ~ log(DAYS) + (1|STRATA) + (1|ADP), data = dat_sub)
t_mod_fit2 <- data.table(DAYS = 7:35)
t_mod_fit2[, MEAN_PROP_N_IN_CELL := predict(t_mod2, newdata = t_mod_fit2, re.form = ~0)]

relate_time_plot_fit <- ggplot(st_compare_smry, aes(x = DAYS, y = MEAN_PROP_N_IN_CELL)) +
  geom_line(aes(color = CELL_EXTENT_km2, group = interaction(CELL_EXTENT_km2, STRATA,ADP))) + scale_color_viridis_c() + labs(x = "Temporal extent of cell in days", y = "Mean proportion of trips per cell", color = "Area") + 
  theme(legend.position = "bottom", legend.key.width = unit(1.5, "cm")) + 
  geom_line(data = t_mod_fit, color = "red", size = 2)

ggplot(dat_sub, aes(x = DAYS, y = MEAN_PROP_N_IN_CELL)) +
  geom_line(aes(color = CELL_EXTENT_km2, group = interaction(CELL_EXTENT_km2, STRATA,ADP))) + scale_color_viridis_c() + labs(x = "Temporal extent of cell in days", y = "Mean proportion of trips per cell", color = "Area") + 
  theme(legend.position = "bottom") + 
  geom_line(data = t_mod_fit2, color = "red", size = 2)

# Split by ADP and stratum
 ggplot(st_compare_smry, aes(x = DAYS, y = MEAN_PROP_N_IN_CELL, color = CELL_EXTENT_km2, group = interaction(CELL_EXTENT_km2, STRATA,ADP))) +
  geom_line() + scale_color_viridis_c() + labs(x = "Temporal extent of cell in days", y = "Mean proportion of trips per cell", color = "Area") + 
  theme(legend.position = "bottom") + facet_grid(STRATA ~ ADP)

# How does a model that incorporates the interaction between space and time differ with the two datasets
mv1 <- lm(MEAN_PROP_N_IN_CELL ~ log(CELL_EXTENT_km2) * log(DAYS), data  = st_compare_smry)
mv2 <- lm(MEAN_PROP_N_IN_CELL ~ log(CELL_EXTENT_km2) * log(DAYS), data  = dat_sub)
coef(mv1)
coef(mv2) 

# TODO Make this into a flextable
mv_mod_coef_tbl <- as.data.table(cbind(
  Dataset = c("Full dataset", "Subset"), 
  round(rbind(
    coef(mv1),
    coef(mv2)
  ),4)
))
 
# Now solve for space
# https://www.symbolab.com/solver/solve-for-equation-calculator - Used this to get equation to solve for AREA
ts_mod_dt <- data.table(DAYS = 1:150)
ts_mod_dt[, AREA := exp( (0.05821 * log(DAYS) + 0.17104) / 0.02847 )]
ts_mod_plot <- ggplot(ts_mod_dt, aes(x = DAYS, y= AREA)) + geom_line(size = 2) +  labs(x = "Days", y = "Area in km2")

# Do the same for the subset of data
s_mod2  # -0.09300 + 0.01019 * ln(s)
t_mod2  # -0.02572 + 0.01884 * ln(t)
# s = exp( (0.01884 * log(DAYS) + 0.06728) / 0.01019  )
ts_mod_dt2 <- data.table(DAYS = 1:36)
ts_mod_dt2[, AREA := exp( (0.01884 * log(DAYS) + 0.06728) / 0.01019  )]
ts_mod_plot2 <- ggplot(ts_mod_dt2, aes(x = DAYS, y= AREA)) + geom_line(size = 2) +  labs(x = "Days", y = "Area in km2")
# Comparing both
ggplot(ts_mod_dt, aes(x = DAYS, y= AREA)) + geom_line(size = 2) +  labs(x = "Days", y = "Area in km2") + 
  geom_line(data = ts_mod_dt2, color = "red", size = 2)
ggplot(ts_mod_dt, aes(x = DAYS, y= AREA)) + geom_line(size = 2) +  labs(x = "Days", y = "Area in km2") + 
  geom_line(data = ts_mod_dt2, color = "red", size = 2) + coord_cartesian(xlim = c(0, 50), ylim = c(0, 1e6))

# Add the cell sizes
space_bins <- unique(st_compare_smry[, .(cell_size, radius, CELL_EXTENT_km2)])
space_bins[, SPACE_LABEL := paste0(cell_size/1e3, ":", radius)]
# Where do the cas bins fall on this?
ts_mod_plot_2 <- ggplot(ts_mod_dt, aes(x = DAYS, y= AREA)) + geom_line(size = 2) +  labs(x = "Days", y = "Area in km2") + 
  geom_hline(data = space_bins, aes(yintercept = CELL_EXTENT_km2), linetype = 2) + 
  geom_text_repel(data = space_bins, aes(x = 0, y = CELL_EXTENT_km2, label = SPACE_LABEL), size = 3) + 
  geom_hline(yintercept = 137732, color = "blue", size = 1.5, linetype = 2) + 
  geom_vline(xintercept = 35, color = "blue", size = 1.5, linetype = 2)
ts_mod_dt[findInterval(137732, AREA)]  # 400km cells corresponds to around 17 days here
ts_mod_dt[findInterval(35, DAYS)]      # 35 days corresponds to around 580km2 cells

# Now all all the designs with their extents and whether P3 is between 0.01 and 0.2!

ts_mod_p3_dt <- unique(st_compare_smry[, .(PS_DEF, DAYS, AREA = CELL_EXTENT_km2)])
ts_mod_p3_dt[, P_3_IN_RANGE := PS_DEF %in% keep_ps_def  ]
ts_mod_plot_3 <- ggplot(ts_mod_dt, aes(x = DAYS, y= AREA)) + geom_line(size = 2) +  labs(x = "Days", y = "Area in km2", color = "P_3 in Range?") + 
  geom_hline(data = space_bins, aes(yintercept = CELL_EXTENT_km2), linetype = 2) + 
  geom_text_repel(data = space_bins, aes(x = 0, y = CELL_EXTENT_km2, label = SPACE_LABEL), size = 3, max.overlaps = 50) + 
  geom_point(data = ts_mod_p3_dt, aes(color = P_3_IN_RANGE), position = position_jitter(width = 1)) + 
  theme(legend.position = "bottom") + scale_y_continuous(trans = "sqrt") + geom_hline(yintercept = 1e6, color = "red") + 
  geom_vline(xintercept = c(8, 40), color = "red")

# Zoom in on the 'good' region
ps_def_overlap_dt <- unique(st_compare_smry[, .(PS_DEF, radius, TIME_OVER)])
ps_def_overlap_dt[, OVER := fcase(
  TIME_OVER == 0 & radius == 0, "Neither",
  TIME_OVER >  0 & radius == 0, "Time",
  TIME_OVER == 0 & radius > 0,  "Space",
  TIME_OVER > 0  & radius > 0,  "Both")]
ts_mod_p3_dt[, OVER := ps_def_overlap_dt[ts_mod_p3_dt, OVER, on = .(PS_DEF)]]
ts_mod_plot_4 <- ggplot(ts_mod_dt, aes(x = DAYS, y= AREA)) + geom_line(size = 2) +  labs(x = "Days", y = "Area in km2", color = "P_3 in Range?") + 
  geom_hline(data = space_bins, aes(yintercept = CELL_EXTENT_km2), linetype = 2) + 
  geom_text_repel(data = space_bins, aes(x = 15, y = CELL_EXTENT_km2, label = SPACE_LABEL), size = 3, max.overlaps = 50) + 
  geom_point(data = ts_mod_p3_dt, aes(color = P_3_IN_RANGE, shape = OVER), position = position_jitter(width = 0.5), size = 2, stroke = 1) + 
  theme(legend.position = "bottom") + scale_y_continuous(limits = c(2.5e4, 1e6)) + 
  xlim(c(15, 40)) + 
  geom_point(y= 137732, x = 35, color = "blue", size = 3, shape = 3, stroke = 2)   # varies in time only

# With subset of data to build line
ggplot(ts_mod_dt, aes(x = DAYS, y= AREA)) + geom_line(size = 2) +  labs(x = "Days", y = "Area in km2", color = "P_3 in Range?") + 
  geom_line(data = ts_mod_dt2, size = 2, color = "red") +
  geom_hline(data = space_bins, aes(yintercept = CELL_EXTENT_km2), linetype = 2) + 
  geom_text_repel(data = space_bins, aes(x = 15, y = CELL_EXTENT_km2, label = SPACE_LABEL), size = 3, max.overlaps = 50) + 
  geom_point(data = ts_mod_p3_dt, aes(color = P_3_IN_RANGE, shape = OVER), position = position_jitter(width = 0.5), size = 2, stroke = 1) + 
  theme(legend.position = "bottom") + scale_y_continuous(limits = c(2.5e4, 1e6)) + 
  xlim(c(15, 40)) + 
  geom_point(y= 137732, x = 35, color = "blue", size = 3, shape = 3, stroke = 2) 

# TODO If i were to redo the box definitions to allow for more temporal levels (just 4 in the subset), I should be able 
# to model a better relationship between space and time. Would have to do someething smaller like (3-day) periods +/- 3 or 6 days!

save(
  effort,
  cell_size_vector, ak_map,
  box_smry_flex_tiny, box_smry_flex_huge, box_smry_flex_cas,
  p3_plot, p3_plot_select,
  relate_space_plot, relate_space_plot_fit, 
  relate_time_plot, relate_time_plot_fit,
  ts_mod_plot, ts_mod_plot_2,  ts_mod_plot_3, ts_mod_plot_4, 
  file = "analyses/spatiotemporal_boxes/spatiotemporal_boxes_analysis_data.RData"
)

#==========================#
# Best box definitions? ####
#==========================#

# These designs meet P3 and both fall right on the curve and also differ only by their extent in time and space:
# cell size and time unit are identical
ps_def_p_3[
  (cell_size == 1.75e5 & radius == 1 & TIME == "WEEK" & TIME_OVER == 1) |
  (cell_size == 1.75e5 & radius == 2 & TIME == "WEEK" & TIME_OVER == 2)]

box_smry_flex(time_space_check_TPC_dt[(cell_size == 1.75e5 & TIME == "WEEK" & TIME_OVER == 1 & radius == 1)])
box_smry_flex(time_space_check_TPC_dt[(cell_size == 1.75e5 & TIME == "WEEK" & TIME_OVER == 2 & radius == 2)])
grid_175km <- stat_area_to_hex_fun(1.75e5, stat_area_sf)
# View size of 175 km cells
ak_map_175 <- ggplot() + 
  geom_sf(data = shp_nmfs, fill = NA, color = "red") + 
  geom_sf(data = shp_land, fill = "gray") + 
  geom_sf(data = grid_175km$HEX_GEOMETRY, fill = NA, color = "blue") + 
  scale_fill_viridis_c(trans = "log", breaks = c(1, 5, 10, 25, 50)) +
  labs(fill = "Trip Counts") + 
  theme(legend.position = "bottom", axis.title = element_blank())

# Even it out at 200?
# P_3 values are slightly less, as would be expected. Still in range (0.1230 and 0.0251)
ps_def_p_3[
  (cell_size == 2e5 & radius == 1 & TIME == "WEEK" & TIME_OVER == 1) |  
  (cell_size == 2e5 & radius == 2 & TIME == "WEEK" & TIME_OVER == 2)]

ps_def_p_3[PS_DEF %in% c(182, 188, 345, 351)][order(cell_size, TIME_OVER)]  # MEAN_P3 for the small boxes is around 0.13, so more harsh on gaps. The other are extremely similar at P_3 around 0.03

# Where are these on the plot?
ggplot(ts_mod_dt, aes(x = DAYS, y = AREA)) + geom_line(size = 2) + labs(x = "Days", y = "Area in km2", color = "P_3 in Range?") + 
  geom_line(data = ts_mod_dt2, size = 2, color = "red") +
  #geom_hline(data = space_bins, aes(yintercept = CELL_EXTENT_km2), linetype = 2) + 
  #geom_text_repel(data = space_bins, aes(x = 15, y = CELL_EXTENT_km2, label = SPACE_LABEL), size = 3, max.overlaps = 50) + 
  geom_text_repel(
    data = ts_mod_p3_dt[PS_DEF %in% c(182, 188, 345, 351)], aes(label = PS_DEF), size = 3, max.overlaps = 50) + 
  geom_point(data = ts_mod_p3_dt[PS_DEF %in% c(182, 188, 345, 351)], aes(color = P_3_IN_RANGE, shape = OVER), position = position_jitter(width = 0.5), size = 2, stroke = 1) + 
  theme(legend.position = "bottom") + scale_y_continuous(limits = c(2.5e4, 1e6)) + 
  xlim(c(15, 40)) 

#==================================================#
# How do these compare with a specified budget? ####
#==================================================#

sample_rate_vec <- seq(from = 0.005, to = 0.800, by = 0.0001)          

s175_1_tW_1 <- calculate_mean_prop_n(
  define_poststrata_fun(effort, space = c(1.75e5, 1.75e5*1), time = c("WEEK", 1), year_strata = c("ADP", "STRATA")),
  sample_rate_vec)
s175_1_tW_2 <- calculate_mean_prop_n(
  define_poststrata_fun(effort, space = c(1.75e5, 1.75e5*2), time = c("WEEK", 2), year_strata = c("ADP", "STRATA")),
  sample_rate_vec)

# For now, let's assume we have a $4.5 budget for monitoring, that OB trips on average cost 
# Use average values from the 2022 Final ADP for now
ob_cpd <- 4118880 / 2844         # $1447.27/day
fgem_cpd <- 1e6 / (632 + 255)    # $1127.40/day
trwem_cpd <- 600                 # $600/day according to JF estimates used in set_budget.R in 2022 Final ADP repo
# Get average trip length for all strata, using TRIP_END - TRIP_START + 1
trip_cost_dt <- unique(val_2018_2021_dt[STRATA != "ZERO", .(ADP, STRATA, TRIP_ID, TRIP_START, TRIP_END)])[
][, .(MEAN_TRIP_DAYS = mean(as.numeric(TRIP_END - TRIP_START, units = "days") + 1)), by = .(ADP, STRATA)]
# Merge in day costs
trip_cost_dt[, CPD := fcase(
  STRATA == "EM_TRW", trwem_cpd,
  STRATA %in% c("EM_POT", "EM_HAL"), fgem_cpd,
  STRATA %in% c("HAL", "POT", "TRW"), ob_cpd)]
# Calculate cost per trip
trip_cost_dt[, CPT := MEAN_TRIP_DAYS * CPD]

# TODO For each design, find range of MEAN_PROP_N that is common to all ADP and STRATA

get_ready_to_allocate <- function(x, costs){
  # x <- copy(s175_1_tW_1); costs <- copy(trip_cost_dt)
  # x <- copy(s175_2_tW_2); costs <- copy(trip_cost_dt)
  

  x1 <- copy(x)
  
  # View 'allocation-background.html' document in 2024_ADP/analyses/allocation_background
  x1[, n := SAMPLE_RATE * N]
  x1[, FPC := (N - n) / N]
  x1[, CV_SCALING := sqrt(FPC * (1/n))]  # As long as n > 1 then CV_scaling should be between 0 and 1
  x1[, INDEX := MEAN_PROP_N_IN_SAMPLED_PS / CV_SCALING]
  
  # Find range of INDEX that is similar to all strata x ADP
  x2 <- x1[
  ][, .(MIN = min(INDEX), MAX = max(INDEX)), by = .(ADP, STRATA)
  ][, .(MIN = max(MIN), MAX = min(MAX)), by = .(ADP)]
  # Subset each year by the index range
  x1 <- do.call(rbind, apply(x2, MARGIN = 1, function(y) {
    x1[ADP == y[["ADP"]]][data.table::between(INDEX, y[["MIN"]], y[["MAX"]])]
  }))
  
  # TODO Make a huge vector of indices (like 1000 cuts?) put it in a table with all strata and ADP, rolling join, get unique values, total the costs.
  
  # TEST What would it cost to get an index of 12 in year 2021?
  index_val <- 11.48
  x3 <- unique(x1[, .(STRATA)])
  x3[, INDEX := index_val]
  x4 <- x1[ADP == 2021][x3, on = .(STRATA, INDEX), roll = "nearest"]
  x4[, TPC := costs[x4, CPT, on = .(STRATA, ADP)]]
  x4[, STRATUM_COST := n * TPC]
  sum(x4$STRATUM_COST)  # Would cost 2.54M  #   # 
  
  # TODO plot the relative rates for the strata as index/budget increases. Do they track uniformly? 
  
  # In 2021, For t1s1, $4M affords index of 10.27, t2s2 affords index of 11.48
  # In 2021, For t1s1, $5M affords index of 12.3, t2s2 affords index of 13.35
  
  
  # t1s1_rates <- copy(x4)
  # t2s2_rates <- copy(x4)
  # t1s1_rates[order(STRATA)]; t2s2_rates[order(STRATA)]
  # ggplot(rbind(cbind(BOX = "t1s1", t1s1_rates), cbind(BOX = "t2s2", t2s2_rates)), aes(x = STRATA, y= SAMPLE_RATE, fill = BOX)) + geom_col(position = "dodge")
  # The rates are pretty similar! With a larger sample rate vector, could get better resolution!
  # The larger boxes results in higher rates for EM_TRW and TRW?
  # 

  
  
}






#=============================#
# EXPLORING OTHER METHODS? ####


library(car)
scatter3d(x = dat_sub$CELL_EXTENT_km2, y = dat_sub$DAYS, z = dat_sub$MEAN_PROP_N_IN_CELL, formula = y~ log(x) * log(y), surface = F, point.col = "black")



# Using just one model?
st_compare_smry
what <- copy(st_compare_smry)
what[, CELL_F := factor(CELL_EXTENT_km2, ordered = T)]
what[, CELL_1e3 := CELL_EXTENT_km2 / 1e3]
what[, DAYS_F := factor(DAYS, ordered = T)]

mm_ss <- lmer(MEAN_PROP_N_IN_CELL ~ sqrt(CELL_1e3) + (CELL_1e3|DAYS_F) + (1|STRATA) + (1|ADP), data = what) 

mm_st <- lmer(MEAN_PROP_N_IN_CELL ~ sqrt(DAYS) + (DAYS|CELL_F) + (1|STRATA) + (1|ADP), data = what) 
scoef <- fixef(mm_ss)
tcoef <- fixef(mm_st)

AIC(
  lmer(MEAN_PROP_N_IN_CELL ~ sqrt(CELL_1e3) + (CELL_1e3|DAYS_F) + (1|STRATA) + (1|ADP), data = what),
  lmer(MEAN_PROP_N_IN_CELL ~ sqrt(CELL_1e3) + (sqrt(CELL_1e3)|DAYS_F) + (1|STRATA) + (1|ADP), data = what)  # AIC is lower?
)


what <- copy(st_compare_smry)
what[, Space := sqrt(CELL_EXTENT_km2)]
what[, Time := sqrt(DAYS)]
what[, Space_F := factor(Space, ordered = T)]
what[, Time_F := factor(Time, ordered = T)]
what[, ADP := factor(ADP, ordered = T)]
library(optimx)

t1 <- lmer(MEAN_PROP_N_IN_CELL ~ Space + (Space|Time_F) + (1|STRATA) + (1|ADP), data = what)
t2 <- lmer(MEAN_PROP_N_IN_CELL ~ Space + (Space|Time_F) + (1|STRATA) + (1|ADP), data = what, control = lmerControl(optimizer = 'optimx', optCtrl = list(method = 'nlminb')))
AIC(t1, t2) # changing optimizer changed the AIC a little bit, fewer warnings?


f1 <- lm(MEAN_PROP_N_IN_CELL ~ Space, data = what)
m1 <- lmer(MEAN_PROP_N_IN_CELL ~ Space + (1|STRATA), data = what)
coef(f1)
fixef(m1)    # mixed model doesn't change fixed effects at all...
AIC(f1, m1)  # Excluding ADP is actually better, but including STRATA is an improvement.
f1_r <- as.data.table(coef(m1)$STRATA, keep.rownames = "STRATA")
ggplot(f1_r, aes(x = Space, y=`(Intercept)`, label = STRATA)) + geom_point() + geom_text()
summary(m1)

m3 <- lmer(MEAN_PROP_N_IN_CELL ~ Space + (1|DAYS), data = what)
m4 <- lmer(MEAN_PROP_N_IN_CELL ~ Space + (1|Time), data = what)
m5 <- lmer(MEAN_PROP_N_IN_CELL ~ Space + (1|Time_F), data = what)
AIC(m3, m4, m5)  # All are identical, just treated as a factor
fixef(m3); fixef(m4); fixef(m5)  #Identical

f2 <- lm(MEAN_PROP_N_IN_CELL ~ Space * Time, data = what)
ggplot(what, aes(x = Space, y = MEAN_PROP_N_IN_CELL)) + geom_point(position = position_jitter(width = 2), alpha=0.5)
ggplot(what, aes(x = Space, y = MEAN_PROP_N_IN_CELL/Time, color = as.factor(Time))) + geom_point(position = position_jitter(width = 2), alpha=0.5) + scale_color_viridis_d() + facet_grid(STRATA~., scales = "free_y")

m6 <- lmer(MEAN_PROP_N_IN_CELL ~ Space + (STRATA|Time), data = what)



f1 <- lm(MEAN_PROP_N_IN_CELL ~ Time, data = what)
m1 <- lmer(MEAN_PROP_N_IN_CELL ~ Time + (1|STRATA), data = what)
coef(f1)
fixef(m1)    # mixed model doesn't change fixed effects at all...
AIC(f1, m1)  # Excluding ADP is actually better, but including STRATA is an improvement.
f1_r <- as.data.table(coef(m1)$STRATA, keep.rownames = "STRATA")
ggplot(f1_r, aes(x = Time, y=`(Intercept)`, label = STRATA)) + geom_point() + geom_text()
summary(m1)  # compared with space, the intercepts for the strata are relatively identical, just scaled differently


test <- copy(what)
test <- test[-sample(nrow(test), size=2000)]
f1 <- lm(MEAN_PROP_N_IN_CELL ~ Time, data = test)
m1 <- lmer(MEAN_PROP_N_IN_CELL ~ Time + (1|STRATA), data = test)
coef(f1)
fixef(m1)  # Not identical, but virtually the same

# Average across strata and ADP?

test <- what[, .(MEAN_PROP_N_IN_CELL = mean(MEAN_PROP_N_IN_CELL)), by = .(PS_DEF, cell_size, radius, TIME, TIME_OVER, CELL_EXTENT_km2, DAYS, Space, Time)]
f2 <- lm(MEAN_PROP_N_IN_CELL ~ Space, data = test)
m2 <- lmer(MEAN_PROP_N_IN_CELL ~ Space + (1|Time), data = test)
coef(f2)
fixef(m2)  # Not identical, but virtually the same
f1  # Model coefficients are basically the same! Just averages across strata! Including time as a random effect is still not useful
f2
m2
# If I used the random intercepts, adjusted these values, and then re-modeled, would I get the same answers?



what[, Space_1e3_sqrt := sqrt(CELL_EXTENT_km2/1e3)]
t3 <- lmer(MEAN_PROP_N_IN_CELL ~ Space_1e3_sqrt + (Space_1e3_sqrt|Time_F) + (1|STRATA) + (1|ADP), data = what)
t4 <- lmer(MEAN_PROP_N_IN_CELL ~ Space_1e3_sqrt + (1|Time_F) + (1|STRATA) + (1|ADP), data = what)
t5 <- lmer(MEAN_PROP_N_IN_CELL ~ Space_1e3_sqrt + (Space_1e3_sqrt|Time_F) + (1|STRATA) + (1|ADP), data = what, control = lmerControl(optimizer = 'optimx', optCtrl = list(method = 'nlminb')))
AIC(t3, t4, t5)  # Not having time as a random slope greatly worsens AIC
fixef(t3); fixef(t4); fixef(t5)  # But he coefficients are literally not any different...
plot(residuals(t3))
plot(residuals(t4))  # Residuals are worse
plot(residuals(t5))  # Same as t3, just don't get warnings by chaning the control....

ranef(t5)$Time_F

# How do different random effects have no differece on the fixed effects?

fixef(lmer(MEAN_PROP_N_IN_CELL ~ Space_1e3_sqrt + (1|ADP), data = what))  # Deleted or adding random effects doesn't change coefficients!

fixef(lmer(MEAN_PROP_N_IN_CELL ~ Space_1e3_sqrt + (1|ADP), data = what)) # Is it because I'm not treating the variable as a category like it probably is?



a <- lm(MEAN_PROP_N_IN_CELL ~ log(CELL_EXTENT_km2) * log(DAYS), data = what)
summary(a)

# TODO EXCLUDE the super large box definitions, restrict to the box in the final figure.
a


# does a mixed model actually do anything with my coefficients?
fm_s <- lm(MEAN_PROP_N_IN_CELL ~ log(CELL_EXTENT_km2), data = what)
mm_s <- lmer(MEAN_PROP_N_IN_CELL ~ log(CELL_EXTENT_km2) + (1|STRATA) + (1|ADP) , data = what) 
coef(fm_s)
t1


t6 <- lmer(MEAN_PROP_N_IN_CELL ~ Time + (Time|Space_F) + (1|STRATA) + (1|ADP), data = what, control = lmerControl(optimizer = 'optimx', optCtrl = list(method = 'nlminb')))
summary(t6)  # boundary fit means one of the random variables is not useful?


t7 <-   lmer(MEAN_PROP_N_IN_CELL ~ Time + (Time|Space_F) + (1|STRATA) + (1|ADP), data = what, control = lmerControl(optimizer = 'optimx', optCtrl = list(method = 'nlminb')))
t8 <-   lmer(MEAN_PROP_N_IN_CELL ~ Time + (1|Space_F) + (1|STRATA) + (1|ADP), data = what, control = lmerControl(optimizer = 'optimx', optCtrl = list(method = 'nlminb')))
fixef(t7); fixef(t8)  # coefficients are the same regardless of if Space_F has a random slope or not. Just causes errors?


# got rid of scaling issues, still failed to converge


space_from_time <- function(x) {
  ((((tcoef[[1]] - scoef[[1]]) + (tcoef[[2]] * sqrt(x)))) / tcoef[[2]]) ^2
}
time_dt <- data.table(DAYS = 7:150)
time_dt[, CELL_EXTENT_km2 := space_from_time(DAYS) * 1e3]
ggplot(time_dt, aes(x = DAYS, y = CELL_EXTENT_km2)) + geom_point()  # why does this only go up to 60K?

((tcoef[[1]] - scoef[[1]]) / tcoef[[2]])^2
(scoef[[2]] / tcoef[[2]])^2
# 16.08381 + 0.05484533*d
space_from_time2 <- function(x) {16.08381 + 0.05484533*x}
time_dt[, CELL_EXTENT2 := space_from_time2(DAYS) * 1e3]
time_dt
# My other plot only goes up to 1.2e7, not 2.5M, so being a little low probably isn't bad? But this is too LOW

mm_ss
mm_st
