# This script compares the different allocation schemes.


#=========#
# TODO Build the allocation designs for cost-weighted boxes and boxes designs.
# TODO For each allocation scheme, calculate optimization metrics, mean_prop_n, CV scaling, etc.
# TODO Grab the allocation methods for status quo, need to include trips_melt metrics
# DONE Apply the 175km cells (+1 neighbor, Week +/- 1 Week) box definition following spatiotemporal_boxes_analysis.
# TODO Compare the Observer to FGEM proximity and Observer to ZERO proximity (another form of mean_prop_n)
# FIXME call MEAN_PROP_N the proximity index?

#=========#

#==================#
# Load Packages ####
#==================#

library(data.table)         # Data wrangling
library(ggplot2)            # Plotting
library(sf)                 # Spatial analyses
library(dplyr)              # Data wrangling sf objects

#===================#
# LOAD Functions ####
#===================#

source("analyses/spatiotemporal_boxes/functions.R")     # Functions for evaluating spatiotemporal proximity of trips

#============================#
# Load data and data prep ####
#============================#

# Fishing effort data from 2018 to 2021
# `spatiotemporal_boxes.rdata' is generated by /analyses/spatiotemporal_boxes/data_prep.R
#load("analyses/spatiotemporal_boxes/spatiotemporal_boxes.RData")   # loads val_2018_2021_dt, a wrangled form of VALHALLA data used for the spatiotemp analysis

load("analyses/allocation_evaluation/allocation_evaluation.RData")   # loads val_2018_2021_dt and in the future, trips_melt

# Simplify the data set
# effort <- unique(val_2018_2021_dt[
# ][STRATA != "ZERO" 
# ][, .(ADP, STRATA, ADFG_STAT_AREA_CODE, WEEK, GEAR, TRIP_ID)
# ][ADFG_STAT_AREA_CODE == 515832, ADFG_STAT_AREA_CODE := 515831        # 515832 is missing from shape file
# ][, TRIP_ID := .GRP, by = .(TRIP_ID)])

# Load the ADFG statistical area shapefile. '../' is needed for Rmarkdown to climb into parent folders.
stat_area_sf <- st_read(
  dsn = "source_data/ADFG_Stat_Area_shapefile/PVG_Statewide_2001_Present_GCS_WGS1984.shp", quiet = T) %>%
  select(STAT_AREA) %>%
  st_transform(crs = 3467)

# Load the Alaska map sf objects
load("source_data/ak_shp.rdata")      # shp_land, shp_nmfs, and shp_centroids added to global

# Trip Costs #
# Use average values from the 2022 Final ADP for now. Also, roughly using trip_end - trip_start + 1 for now until we get
# a better handle on future monitoring costs.
ob_cpd <- 4118880 / 2844         # $1447.27/day
fgem_cpd <- 1e6 / (632 + 255)    # $1127.40/day
trwem_cpd <- 600                 # $600/day according to JF estimates used in set_budget.R in 2022 Final ADP repo
# Get average trip length for all strata, using TRIP_END - TRIP_START + 1
trip_cost_dt <- unique(val_2018_2021_dt[STRATA != "ZERO", .(ADP, STRATA, TRIP_ID, START, END)])[
][, .(MEAN_TRIP_DAYS = mean(as.numeric(END - START, units = "days") + 1)), by = .(ADP, STRATA)]
# Merge in day costs
trip_cost_dt[, CPD := fcase(
  STRATA == "EM_TRW", trwem_cpd,
  STRATA %in% c("EM_POT", "EM_HAL"), fgem_cpd,
  STRATA %in% c("HAL", "POT", "TRW"), ob_cpd)]
# Calculate cost per trip
trip_cost_dt[, CPT := MEAN_TRIP_DAYS * CPD]

#=========================#
# Apply box definition ####
#=========================#

# Prepare a data set for allocation based on box definitions.
test <- unique(val_2018_2021_dt[POOL != "ZE", .(ADP, POOL, STRATA, FMP_MT, ADFG_STAT_AREA_CODE, WEEK, TRIP_ID)])

box_def <- define_poststrata(
  test, stratum_cols = c("ADP", "STRATA"), 
  space = c(1.75e5, 1.75e5*1), time = c("WEEK", 1))

box_def_with_strata <- define_poststrata(
  test, stratum_cols = c("ADP", "STRATA", "FMP_MT"),
  space = c(1.75e5, 1.75e5*1), time = c("WEEK", 1))

# Set the sample rate vector. to = 0.8 is sufficient when not stratifying with FMP, but with FMP, needs to be higher!
sample_rate_vec <- seq(from = 0.005, to = 0.95, by = 0.0001) 
box_def_mean_prop_n <- calculate_mean_prop_n(box_def, sample_rate_vec)
box_def_with_strata_mean_prop_n <- calculate_mean_prop_n(box_def_with_strata, sample_rate_vec)

#================================#
# Gaps + CV Allocation Method ####
#================================#

# Calculate Indices
allocation_gaps_CV <- calculate_index(box_def_mean_prop_n, trip_cost_dt)
allocation_gaps_CV_FMP <- calculate_index(box_def_with_strata_mean_prop_n, trip_cost_dt)

ggplot(allocation_gaps_CV$melt, aes(x = INDEX_COST/1e6, y = value, color = STRATA)) + facet_grid(variable ~ ADP, scales = "free_y") + geom_line(size = 1) + 
  theme(legend.position = "bottom") + geom_vline(xintercept = 4, linetype = 2) + 
  labs(subtitle = "Gaps + CV. Dashed line indicates total budget of $4M", x = "Cost ($ Million)")
ggplot(allocation_gaps_CV_FMP$melt, aes(x = INDEX_COST/1e6, y = value, color = STRATA)) + facet_grid(variable ~ ADP + FMP_MT, scales = "free_y") + geom_line(size = 1) + 
  theme(legend.position = "bottom") + geom_vline(xintercept = 4, linetype = 2) + 
  labs(subtitle = "Gaps + CV. Dashed line indicates total budget of $4M", x = "Cost ($ Million)")

dcast(
  allocation_gaps_CV$rates[, .SD[findInterval(4e6, INDEX_COST)], by = c(attr(allocation_gaps_CV, "stratum_cols"))],
  STRATA ~ ADP, value.var = c("SAMPLE_RATE"))
dcast(
  allocation_gaps_CV_FMP$rates[, .SD[findInterval(4e6, INDEX_COST)], by = c(attr(allocation_gaps_CV_FMP, "stratum_cols"))],
  STRATA + FMP_MT ~ ADP, value.var = c("SAMPLE_RATE"))

allocation_gaps_CV$rates[, .SD[findInterval(4e6, INDEX_COST)], by = c(attr(allocation_gaps_CV, "stratum_cols"))][ADP==2021]
allocation_gaps_CV_FMP$rates[, .SD[findInterval(4e6, INDEX_COST)], by = c(attr(allocation_gaps_CV_FMP, "stratum_cols"))][ADP==2021]

#================================#
# Gaps only Allocation Method ####
#================================#

# The same as before but does not include CV

allocation_gaps <- calculate_gaps(box_def_mean_prop_n, trip_costs_dt)
ggplot(allocation_gaps$melt, aes(x = INDEX_COST/1e6, y = value, color = STRATA)) + facet_grid(variable ~ ADP, scales = "free_y") + geom_line(size = 1) + 
  theme(legend.position = "bottom") + geom_vline(xintercept = 4, linetype = 2) + 
  labs(subtitle = "Gaps Only. Dashed line indicates total budget of $4M", x = "Cost ($ Million)")

allocation_gaps_FMP <- calculate_gaps(box_def_with_strata_mean_prop_n, trip_costs_dt)
ggplot(allocation_gaps_FMP$melt, aes(x = INDEX_COST/1e6, y = value, color = STRATA)) + facet_grid(variable ~ ADP + FMP_MT, scales = "free_y") + geom_line(size = 1) + 
  theme(legend.position = "bottom") + geom_vline(xintercept = 4, linetype = 2) + 
  labs(subtitle = "Gaps Only. Dashed line indicates total budget of $4M", x = "Cost ($ Million)")

#========================#
# Cost-Weighted Boxes ####
#========================#

trip_cost_dt

# According to the ADP Analytic Plan:  It uses a variation on Neyman allocation which minimizes the proportion of 
# post-strata with no data for a given budget.
# Neyman allocation is a special case of optimal allocation where the costs per unit are the same for all strata (THIS IS NOT TRUE!)
# Optimal allocation balances stratum costs, variance, and stratum sizes. Do I just replace variance with prop_box?

# So instead of MEAN_PROP_N, need to calculate NUMBER OF BOXES likely to be sampled.
# Should be able to do this mathematically? 
# TODO Simulate sampling to calculate proprtion of boxes sampled?
# Or instead of MEAN_PROP_N, simply get the average probability that each box is sampled? Compare with simulated results!

cwb_prop <- calculate_mean_prop_box(box_def, sample_rate_vec)

# For each year, see how sample rate affects the average proportion of boxes likely to be sampled.
ggplot(cwb_prop, aes(x = SAMPLE_RATE, y = MEAN_PROP_BOX, color = STRATA)) + facet_grid(. ~ ADP) + geom_line(size = 1) + theme(legend.position = "bottom")

# https://documentation.sas.com/doc/en/statcdc/14.2/statug/statug_surveyselect_details22.htm
# (Nh * Sh / sqrt(Ch)) / sum[ (Ni * Si) / sqrt(Ci) ]
# With optimal allocation, 'variance' is a known quantity to plug into the formula. Here, we just brute force it such that 
# prop_box is the same for all strata?

# Or do I simply weigh by MEAN_PROP_BOX / sqrt(CPT), not N?

# normally, S (variance) is a numerator so that we try to allocate more samples to higher-variance strata
# However, MEAN_PROP_BOX is 'better' is it increases, so put it in the denominator?

test <- cwb_prop[trip_cost_dt, on = .(ADP, STRATA)]

# FIXME I don't know what I'm doing here!

test[, STRATUM_NSC := 1 / MEAN_PROP_BOX * sqrt(CPT)]
setattr(test, "stratum_cols", attr(cwb_prop, "stratum_cols"))

nsc_range <- test[
][, setNames(as.list(range(STRATUM_NSC)), c("MIN", "MAX")), by = c(attr(test, "stratum_cols"), "N")
][, .(MIN = max(MIN), MAX = min(MAX)), by = c("ADP")]

nsc_dt <- apply(nsc_range, 1, function(x) {
  # Could go up to 1e5 or even higher if you want more resolution, but plotting will be very slow!
  nsc_vector <- data.table(ADP = x[["ADP"]], STRATUM_NSC = seq(x[["MIN"]], x[["MAX"]], by = (x[["MAX"]] - x[["MIN"]])/1e4))
})
nsc_join <- rbindlist(lapply(nsc_dt, function(x) test[, .SD[x, on = .(ADP, STRATUM_NSC), roll = "nearest"], by = .(STRATA)]))
setkey(nsc_join, ADP, STRATUM_NSC, STRATA)
nsc_join
# TODO This was super fast! Do I use this same syntax for the prior joins?

nsc_join[, STRATUM_NSC := N * MEAN_PROP_BOX / sqrt(CPT)]  
nsc_join[, TOTAL_NSC := sum(STRATUM_NSC), by = .(ADP, MEAN_PROP_BOX)]
nsc_join[, Wh := STRATUM_NSC / TOTAL_NSC]
nsc_join[, TOTAL_COST := sum(N * SAMPLE_RATE * CPT), by = .(ADP, MEAN_PROP_BOX)]

# Find what rates afford a $4M program
test2 <- data.table(ADP = 2021, TOTAL_COST = 4e6)
nsc_join[, .SD[test2, on = .(ADP, TOTAL_COST), roll = "nearest"], by = .(STRATA)]  # Approx 0.795%

#===============#
# Boxes Only ####
#===============#

# FIXME Rename all variabes below from cwb (cost-weighted-boxes) to something else like 'box_only'

cwb_range <- cwb_prop[
][, setNames(as.list(range(MEAN_PROP_BOX)), c("MIN", "MAX")), by = c(attr(cwb_prop, "stratum_cols"), "N")
][, .(MIN = max(MIN), MAX = min(MAX)), by = c("ADP")]

cwb_dt <- apply(cwb_range, 1, function(x) {
  # Could go up to 1e5 or even higher if you want more resolution, but plotting will be very slow!
  cwb_vector <- data.table(ADP = x[["ADP"]], MEAN_PROP_BOX = seq(x[["MIN"]], x[["MAX"]], by = (x[["MAX"]] - x[["MIN"]])/1e4))
})
cwb_join <- rbindlist(lapply(cwb_dt, function(x) cwb_prop[, .SD[x, on = .(ADP, MEAN_PROP_BOX), roll = "nearest"], by = .(STRATA)]))
# TODO This was super fast! Do I use this same syntax for the prior joins?
ggplot(cwb_join, aes(x = SAMPLE_RATE, y = MEAN_PROP_BOX, color = STRATA)) + geom_line(size = 1) + facet_grid(. ~ ADP)

cwb_join <- cwb_join[trip_cost_dt, on = .(ADP, STRATA)]   # Merge in cost of sampling each stratum
setkey(cwb_join, ADP, MEAN_PROP_BOX, ADP)

cwb_join[, STRATUM_NSC := N * MEAN_PROP_BOX / sqrt(CPT)]  
cwb_join[, TOTAL_NSC := sum(STRATUM_NSC), by = .(ADP, MEAN_PROP_BOX)]
cwb_join[, Wh := STRATUM_NSC / TOTAL_NSC]
cwb_join[, TOTAL_COST := sum(N * SAMPLE_RATE * CPT), by = .(ADP, MEAN_PROP_BOX)]

# Find what rates afford a $4M program
test <- data.table(ADP = 2021, TOTAL_COST = 4e6)
cwb_join[, .SD[test, on = .(ADP, TOTAL_COST), roll = "nearest"], by = .(STRATA)]  # Approx 0.795%
# Wait.. this wasn't weighted by cost tho... 
# FIXME START OVER! Calculate STRATUM_NSC for full range, then find overlapping ranges, etc?
# I tink what I did above was weighbted by box only



#======================================#
# Compare rates at $4M program size ####
#======================================#

# Note that since I've allowed trips to belong to multiple weeks (instead of week centered on start and end), overlap increased,
# So HAL is 
dcast(
  allocation_gaps_CV$rates[, .SD[findInterval(4e6, INDEX_COST)], by = c(attr(allocation_gaps_CV, "stratum_cols"))],
  STRATA ~ ADP, value.var = c("SAMPLE_RATE")
)

dcast(
  allocation_gaps$rates[, .SD[findInterval(4e6, INDEX_COST)], by = c(attr(allocation_gaps_CV, "stratum_cols"))],
  STRATA ~ ADP, value.var = c("SAMPLE_RATE")
)

allocation_gaps_CV$rates[, .SD[findInterval(4e6, INDEX_COST)], by = c(attr(allocation_gaps_CV, "stratum_cols"))][ADP==2021]
allocation_gaps$rates[, .SD[findInterval(4e6, INDEX_COST)], by = c(attr(allocation_gaps, "stratum_cols"))][ADP==2021]
# Can see that without CV, TRW and EM_TRW rates a significantly lower, resulting in higher coverage on other strata except for EM_POT

# TODO Mean_Prop N, CV scaling
allocation_gaps_CV$rates[, .SD[findInterval(4e6, INDEX_COST)], by = c(attr(allocation_gaps_CV, "stratum_cols"))][ADP==2021][, lapply(.SD, mean), .SDcols = c("MEAN_PROP_N_IN_SAMPLED_PS", "CV_SCALING")]
allocation_gaps$rates[, .SD[findInterval(4e6, INDEX_COST)], by = c(attr(allocation_gaps, "stratum_cols"))][ADP==2021][, lapply(.SD, mean), .SDcols = c("MEAN_PROP_N_IN_SAMPLED_PS", "CV_SCALING")]
# Keeping the STRATA un-scaled, both gaps are better (higher) and CV_scaling is better (lower) 

# TODO Scaled by stratum size, it's still better! Should scale by STRATUM size if you want to make comparisons with other stratum definitions too?
allocation_gaps_CV$rates[, .SD[findInterval(4e6, INDEX_COST)], by = c(attr(allocation_gaps, "stratum_cols"))][ADP==2021][, lapply(.SD, weighted.mean, N), .SDcols = c("MEAN_PROP_N_IN_SAMPLED_PS", "CV_SCALING")]
allocation_gaps$rates[, .SD[findInterval(4e6, INDEX_COST)], by = c(attr(allocation_gaps, "stratum_cols"))][ADP==2021][, lapply(.SD, weighted.mean, N), .SDcols = c("MEAN_PROP_N_IN_SAMPLED_PS", "CV_SCALING")]
# By including CV scaling, MEAN_PROP_N for EM_TRW and TRW can increase greatly. Without CV_scaling in the allocation, EM_TRW and TRW have huge (bad) CV_SCALING values even when weighted by N
# This shows that by putting more samples into TRW, you get fairly cost-efficient benefits to both MEAN_PROP_N and especially CV_SCALING


#==========================================#
# How many Observer Days can we expect? ####
#==========================================#

allocation_gaps_CV$rates[, .SD[findInterval(4e6, INDEX_COST)], by = .(ADP, STRATA)][ADP == 2021]
allocation_gaps_CV$rates[, .SD[findInterval(4.5e6, INDEX_COST)], by = .(ADP, STRATA)][ADP == 2021]

# Question: Are the costs here realistic? are we affording 2000 sea days?
test <- allocation_gaps_CV$rates[, .SD[findInterval(4e6, INDEX_COST)], by = .(ADP, STRATA)][ADP == 2021]
test <- trip_cost_dt[test[, -"CPT"], on = .(ADP, STRATA)]
test[, DAYS := n*MEAN_TRIP_DAYS]
test[, sum(DAYS), by = (STRATA %like% "EM")]  # Only 1820 sea days with $4M program

test <- allocation_gaps_CV$rates[, .SD[findInterval(4.5e6, INDEX_COST)], by = .(ADP, STRATA)][ADP == 2021]
test <- trip_cost_dt[test[, -"CPT"], on = .(ADP, STRATA)]
test[, DAYS := n*MEAN_TRIP_DAYS]
test[, sum(DAYS), by = (STRATA %like% "EM")] 

# 2055 sea days with $4M program, so not likely to get much cost-efficiency from optional days!
# Assuming these cost estimates are reasonable, might make sense to not have a 2000 day minimum if we can avoid it...

#====================#
# Stratify by FMP ####
#====================#

effort_fmp <- unique(val_2018_2021_dt[
][STRATA != "ZERO" 
][, FMP := ifelse(NMFS_AREA > 600, "GOA", "BSAI")
][, .(ADP, STRATA, FMP, ADFG_STAT_AREA_CODE, WEEK, GEAR, TRIP_ID)
][ADFG_STAT_AREA_CODE == 515832, ADFG_STAT_AREA_CODE := 515831        # 515832 is missing from shape file
][, TRIP_ID := .GRP, by = .(TRIP_ID)])
ps_fmp <- define_poststrata(effort_fmp, space = c(1.75e5, 1.75e5*1), time = c("WEEK", 1), stratum_cols = c("ADP", "STRATA", "FMP"))

ps_fmp_prop_n <- calculate_mean_prop_n(ps_fmp, sample_rate_vec)  
ps_fmp_index <- calculate_index(ps_fmp_prop_n, trip_cost_dt)
# If we stratify by STRATA and FMP, what rates would $4M give us?
ps_fmp_index$rates[, .SD[findInterval(4e6, INDEX_COST)], by = .(ADP, STRATA, FMP)][ADP == 2021]  # make sure 'by' is same as 'stratum_cols' attribute!

# How does number of monitored trips per strata change?
ps_fmp_index$rates[, .SD[findInterval(4e6, INDEX_COST)], by = .(ADP, STRATA, FMP)][ADP == 2021][, .(n  = sum(n)), keyby = .(STRATA)]
s175_1_tW_1_index$rates[, .SD[findInterval(4e6, INDEX_COST)], by = .(ADP, STRATA)][ADP == 2021][order(STRATA)]
# Hmm, splitting by FMP results in more coverage for POT, but less for EM_HAL and EM_TRW

# FIXME Some trips fished in both FMP and BSAI - I didnt split there before, so in 2021 there were 4322 total trips
# whereas there are only 4271 unique TRIP_IDs!. Can't use val_2018_2021_dt for this, have to remake it, splitting by FMP by tonnage?
multi_fmp <- effort_fmp[, .SD[uniqueN(FMP) > 1,], by = .(TRIP_ID)]
multi_fmp[, .(MULTI_FMP_TRIP = uniqueN(TRIP_ID)), keyby = .(STRATA, ADP)]  #Most multi-FMP trips are in HAL and EM_HAL
# Separating BS and AI (instead of BSAI together) would create more strata, likely wouldn't help much?



