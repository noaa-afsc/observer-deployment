# This script compares the different allocation schemes.


#=========#
# TODO Build the allocation designs for cost-weighted boxes and boxes designs.
# TODO For each allocation scheme, calculate optimization metrics, mean_prop_n, CV scaling, etc.
# TODO Grab the allocation methods for status quo, need to include trips_melt metrics
# DONE Apply the 175km cells (+1 neighbor, Week +/- 1 Week) box definition following spatiotemporal_boxes_analysis.
# TODO Compare the Observer to FGEM proximity and Observer to ZERO proximity (another form of mean_prop_n)
# FIXME call MEAN_PROP_N the proximity index?

#=========#

#==================#
# Load Packages ####
#==================#

library(data.table)         # Data wrangling
library(ggplot2)            # Plotting
library(sf)                 # Spatial analyses
library(dplyr)              # Data wrangling sf objects
library(flextable)          # Nicer tables in RMarkdown
library(officer)            # Better formatting of flextables

#===================#
# LOAD Functions ####
#===================#

source("analyses/spatiotemporal_boxes/functions.R")     # Functions for evaluating spatiotemporal proximity of trips

#============================#
# Load data and data prep ####
#============================#

# Fishing effort data from 2018 to 2021
# `spatiotemporal_boxes.rdata' is generated by /analyses/spatiotemporal_boxes/data_prep.R
#load("analyses/spatiotemporal_boxes/spatiotemporal_boxes.RData")   # loads val_2018_2022_dt, a wrangled form of VALHALLA data used for the spatiotemp analysis

load("analyses/allocation_evaluation/allocation_evaluation.RData")   # loads val_2018_2022_dt and in the future, trips_melt

# Load the ADFG statistical area shapefile. '../' is needed for Rmarkdown to climb into parent folders.
stat_area_sf <- st_read(
  dsn = "source_data/ADFG_Stat_Area_shapefile/PVG_Statewide_2001_Present_GCS_WGS1984.shp", quiet = T) %>%
  select(STAT_AREA) %>%
  st_transform(crs = 3467)

# Load the Alaska map sf objects
load("source_data/ak_shp.rdata")      # shp_land, shp_nmfs, and shp_centroids added to global

# Trip Costs #
# Use average values from the 2023 Final ADP for now. Also, roughly using trip_end - trip_start + 1 for now until we get
# a better handle on future monitoring costs.
ob_cpd <- 4896623 / 3094         # $1582.619/day
fgem_cpd <- 1e6 / (1040+735)     # $ 563.380/day
trwem_cpd <- 600                 # $600/day according to JF estimates used in set_budget.R in 2022 Final ADP repo
# Get average trip length for all strata, using TRIP_END - TRIP_START + 1

# This function counts number of unique days between each trip target date and landing date
# use this to count days for non-observed trips, which already have a modeled 'DAYS' estimate.
day_count <- function(x) {
  length(unique(unlist(apply(x, 1, function(y) as.numeric(as.Date(y[1])) : as.numeric(as.Date(y[2])), simplify = F))))
}
val_2018_2022_dt[POOL != "OB", DAYS := day_count(.SD), by = .(TRIP_ID), .SDcols = c("TRIP_TARGET_DATE", "LANDING_DATE")]
trip_cost_dt <- unique(val_2018_2022_dt[, .(ADP, STRATA, TRIP_ID, DAYS)])[, .(MEAN_TRIP_DAYS = mean(DAYS)), by = .(ADP, STRATA)]
# trip_cost_dt <- unique(val_2018_2022_dt[STRATA != "ZERO", .(ADP, STRATA, TRIP_ID, START, END)])[
# ][, .(MEAN_TRIP_DAYS = mean(as.numeric(END - START, units = "days") + 1)), by = .(ADP, STRATA)]
# Merge in day costs
trip_cost_dt[, CPD := fcase(
  STRATA == "EM_TRW", trwem_cpd,
  STRATA %in% c("EM_POT", "EM_HAL"), fgem_cpd,
  STRATA %in% c("OB_HAL", "OB_POT", "OB_TRW"), ob_cpd)]
# Calculate cost per trip
trip_cost_dt[, CPT := MEAN_TRIP_DAYS * CPD]
trip_cost_dt[STRATA == "ZERO", ':=' (CPD = 0, CPT = 0)]

# In future year (option year 4, assuming 3% increases ever year until 2028-2029),
trip_cost_future <- copy(trip_cost_dt)
trip_cost_future[, ':=' (CPD = CPD * 1.03^5, CPT = CPT * 1.03^5)]

# Travel costs 

# 2023 Final ADP costs : 
# At-sea Observer : 4896623 /3094 days = 1582.619 
# FG-EM : 1e6 / 1775 days = 563.3803 (this is way less than previous estimate)
# Assuming $1834.34 per day and a 4.5M budget:
4.5e6 / 1834.34  # 2453 days
4.0e6 / 1834.34  # 2180 days
3.5e6 / 1834.34  # 1908 days (assuming a $4.5 program, $1M to EM, and not accounting for no option days)

# Looking at days_paid, found that travel costs roughly track a 3% inflation, and that travel costs are $320.818 in 2017
# Ignoring travel costs in 2019 and 2020 since they were greatly affected by covid. In 2022, had a travel cost per sea day
# of 376.70. 

# If we assume a 2000 day minimum and a projected cost per day of $1643.50 (option year 4 in 2028-2029 assuming 3% increaeses from
# previous contract, with $376.70 * (1.03)^(6) = $449.80 per travel day, total cost of 
(1643.50 + 449.80) * 2000 # = $ 4.1866 M for observer coverage

# According to Darrell, we can't expect revenues to track inflation, in fact, trends suggest they fall short of inflation.
# See e-mail chain 2023-Feb-23
# https://www.oecd-ilibrary.org/sites/19428846-en/1/3/8/index.html?itemId=/content/publication/19428846-en&_csp_=78a77099f3b0c6eae1de8bfe93d3b09e&itemIGO=oecd&itemContentType=book#section-d1e21762
# Using Figure 8.2 and the 'capture' section, prices in 2020 are around $1800/t and are around $2050/t in 2028.
# 2050 = 1800 * x^8
# 1.138889 = x^8
# 1.138889 ^ (1/8) = 1.01639 = x
1800 * 1.01639^8


#=========================#
# Apply box definition ####
#=========================#

# Prepare a data set for allocation based on box definitions.
test <- unique(val_2018_2022_dt[POOL != "ZE", .(ADP, POOL, STRATA, BSAI_GOA, BS_AI_GOA, ADFG_STAT_AREA_CODE, TRIP_TARGET_DATE, LANDING_DATE, TRIP_ID)])

# For now, use center of trip _start_date and landing_date to define week of each trip
test[, WEEK := week( 
  min(TRIP_TARGET_DATE, LANDING_DATE) + 
    as.numeric(max(TRIP_TARGET_DATE, LANDING_DATE) - min(TRIP_TARGET_DATE, LANDING_DATE), units = "days" ) / 2), 
  by = .(TRIP_ID)]

target_budgets <- data.table(INDEX_COST = c(3e6, 4e6, 5e6))

box_def <- define_poststrata(
  test, stratum_cols = c("ADP", "STRATA"), 
  space = c(2e5, 2e5*1), time = c("WEEK", 1))

box_def_with_strata <- define_poststrata(
  test, stratum_cols = c("ADP", "STRATA", "BSAI_GOA"),
  space = c(2e5, 2e5*1), time = c("WEEK", 1))

box_def_bs_ai_goa <- define_poststrata(
  test, stratum_cols = c("ADP", "STRATA", "BS_AI_GOA"),
  space = c(2e5, 2e5*1), time = c("WEEK", 1))

box_def_week <- define_poststrata_geom_time(
  test, stratum_cols = c("STRATA"), year_col = "ADP",
  space = c(2e5, 2e5*1), time = c("week", 1, "TRIP_TARGET_DATE", "LANDING_DATE")
)

# Set the sample rate vector. to = 0.8 is sufficient when not stratifying with FMP, but with FMP, needs to be higher!
sample_rate_vec <- seq(from = 0.005, to = 0.95, by = 0.0001) 
box_def_mean_prop_n <- calculate_mean_prop_n(box_def, sample_rate_vec)
box_def_with_strata_mean_prop_n <- calculate_mean_prop_n(box_def_with_strata, sample_rate_vec)
box_def_bs_ai_goa_mean_prop_n <- calculate_mean_prop_n(box_def_bs_ai_goa, sample_rate_vec)
box_def_week_mean_prop_n <- calculate_mean_prop_n(box_def_week, sample_rate_vec)


#================================#
# Gaps + CV Allocation Method ####
#================================#

# Calculate Indices (each will take a few minutes)
allocation_gaps_CV <- calculate_index(box_def_mean_prop_n, trip_cost_dt)
allocation_gaps_CV_FMP <- calculate_index(box_def_with_strata_mean_prop_n, trip_cost_dt)
allocation_gaps_CV_bs_ai_goa <- calculate_index(box_def_bs_ai_goa_mean_prop_n, trip_cost_dt)
allocation_gaps_week <- calculate_index(box_def_week_mean_prop_n, trip_cost_dt) 

allocation_gaps_CV$melt[
][variable == "MEAN_PROP_N_IN_SAMPLED_PS", variable := "INTERSPERSION"
][, variable := factor(variable, levels = c("INTERSPERSION", "CV_SCALING", "INDEX", "SAMPLE_RATE")) ]
ggplot(allocation_gaps_CV$melt, aes(x = INDEX_COST/1e6, y = value, color = STRATA)) + facet_grid(variable ~ ADP, scales = "free_y") + geom_line(size = 1) + 
  theme(legend.position = "bottom") + geom_vline(xintercept = 4, linetype = 2) + 
  labs(subtitle = "Interspersion / CV. Dashed line indicates total budget of $4M", x = "Cost ($ Million)")

allocation_gaps_CV_tbl <- allocation_gaps_CV$rates[
][ADP == 2021, .SD[target_budgets, on = .(INDEX_COST), roll = "nearest"], by = .(STRATA)
][, .(BUDGET = INDEX_COST, STRATA, INTERSPERSION = MEAN_PROP_N_IN_SAMPLED_PS, CV_SCALING, INDEX, SAMPLE_RATE, N, n)
][order(BUDGET, STRATA)] %>%
  flextable() %>% colformat_double(j = c(3, 4, 5, 6), digits = 4)  %>% colformat_double(j = c(1,8), digits = 0) %>%
  hline(i = c(6, 12), border = fp_border(style = "dashed")) %>% autofit()

allocation_gaps_CV__FMP_tbl <- allocation_gaps_CV_FMP$rates[
][ADP == 2022, .SD[target_budgets, on = .(INDEX_COST), roll = "nearest"], by = .(STRATA, BSAI_GOA)
][, .(BUDGET = INDEX_COST, STRATA, BSAI_GOA, INTERSPERSION = MEAN_PROP_N_IN_SAMPLED_PS, CV_SCALING, INDEX, SAMPLE_RATE, N, n)
][order(BUDGET, STRATA, BSAI_GOA)] %>%
  flextable() %>% colformat_double(j = c(4, 5, 6, 7), digits = 4)  %>% colformat_double(j = c(1,9), digits = 0) %>%
  hline(i = c(11, 22), border = fp_border(style = "dashed")) %>% autofit()

allocation_gaps_CV_FMP$melt[
][variable == "MEAN_PROP_N_IN_SAMPLED_PS", variable := "INTERSPERSION"
][, variable := factor(variable, levels = c("INTERSPERSION", "CV_SCALING", "INDEX", "SAMPLE_RATE")) ]
ggplot(allocation_gaps_CV_FMP$melt, aes(x = INDEX_COST/1e6, y = value, color = STRATA)) + facet_grid(variable ~ ADP + FMP_MT, scales = "free_y") + geom_line(size = 1) + 
  theme(legend.position = "bottom") + geom_vline(xintercept = 4, linetype = 2) + 
  labs(subtitle = "Gaps + CV. Dashed line indicates total budget of $4M", x = "Cost ($ Million)")

dcast(
  allocation_gaps_CV$rates[, .SD[findInterval(4e6, INDEX_COST)], by = c(attr(allocation_gaps_CV, "stratum_cols"))],
  STRATA ~ ADP, value.var = c("SAMPLE_RATE"))
dcast(
  allocation_gaps_CV_FMP$rates[, .SD[findInterval(4e6, INDEX_COST)], by = c(attr(allocation_gaps_CV_FMP, "stratum_cols"))],
  STRATA + FMP_MT ~ ADP, value.var = c("SAMPLE_RATE"))

allocation_gaps_CV$rates[, .SD[findInterval(4e6, INDEX_COST)], by = c(attr(allocation_gaps_CV, "stratum_cols"))][ADP==2022]
allocation_gaps_CV_FMP$rates[, .SD[findInterval(4e6, INDEX_COST)], by = c(attr(allocation_gaps_CV_FMP, "stratum_cols"))][ADP==2022]
allocation_gaps_week$rates[, .SD[findInterval(4e6, INDEX_COST)], by = c(attr(allocation_gaps_CV, "stratum_cols"))][ADP==2022]
# With the new method for defining WEEK, the result is essentially the same! 
# Unsurprisingly, HAL and POT that have longer trips are slightly more likely to span multiple weeks, so they are going to get 
# more overlap than TRW.

#================================#
# Gaps only Allocation Method ####
#================================#

# The same as before but does not include CV

allocation_gaps <- calculate_gaps(box_def_mean_prop_n, trip_costs_dt)
allocation_gaps$melt[
][variable == "MEAN_PROP_N_IN_SAMPLED_PS", variable := "INTERSPERSION"
][, variable := factor(variable, levels = c("INTERSPERSION", "SAMPLE_RATE")) ]
ggplot(allocation_gaps$melt, aes(x = INDEX_COST/1e6, y = value, color = STRATA)) + facet_grid(variable ~ ADP, scales = "free_y") + geom_line(size = 1) + 
  theme(legend.position = "bottom") + geom_vline(xintercept = 4, linetype = 2) + 
  labs(subtitle = "Interspersion only. Dashed line indicates total budget of $4M", x = "Cost ($ Million)")

# Compare averages of the metrics at a range of budgets
int_only_mean <- copy(allocation_gaps$rates)[
][, INDEX := MEAN_PROP_N_IN_SAMPLED_PS / CV_SCALING
][ADP==2021, .SD[target_budgets, on = .(INDEX_COST), roll = "nearest"], by = .(STRATA)
][order(INDEX_COST, STRATA)][]
setnames(int_only_mean, c("MEAN_PROP_N_IN_SAMPLED_PS", "INDEX_COST"), c("INTERSPERSION", "BUDGET"))

int_cv_mean <- copy(allocation_gaps_CV$rates)[
][ADP==2021, .SD[target_budgets, on = .(INDEX_COST), roll = "nearest"], by = .(STRATA)
][order(INDEX_COST, STRATA)][]
setnames(int_cv_mean, c("MEAN_PROP_N_IN_SAMPLED_PS", "INDEX_COST"), c("INTERSPERSION", "BUDGET"))

metric_compare <- rbind(
  cbind(METHOD = "INT Only", int_only_mean[, lapply(.SD, mean), by = .(BUDGET, ADP), .SDcols = c("INTERSPERSION", "CV_SCALING", "INDEX", "n")]),
  cbind(METHOD = "INT / CV", int_cv_mean[, lapply(.SD, mean), by = .(BUDGET, ADP), .SDcols = c("INTERSPERSION", "CV_SCALING", "INDEX", "n")])
)[, METHOD := factor(METHOD, levels = c("INT Only", "INT / CV"))][order(ADP, BUDGET, METHOD)][]
setcolorder(metric_compare, c("ADP", "BUDGET", "METHOD"))
metric_compare


allocation_gaps_FMP <- calculate_gaps(box_def_with_strata_mean_prop_n, trip_costs_dt)
ggplot(allocation_gaps_FMP$melt, aes(x = INDEX_COST/1e6, y = value, color = STRATA)) + facet_grid(variable ~ ADP + FMP_MT, scales = "free_y") + geom_line(size = 1) + 
  theme(legend.position = "bottom") + geom_vline(xintercept = 4, linetype = 2) + 
  labs(subtitle = "Interspersion only. Dashed line indicates total budget of $4M", x = "Cost ($ Million)")

allocation_gaps_tbl <- allocation_gaps$rates[
][ADP == 2021, .SD[target_budgets, on = .(INDEX_COST), roll = "nearest"], by = .(STRATA)
][, .(BUDGET = INDEX_COST, STRATA, INTERSPERSION = MEAN_PROP_N_IN_SAMPLED_PS, SAMPLE_RATE, N, n)
][order(BUDGET, STRATA)] %>%
  flextable() %>% colformat_double(j = c(3, 4), digits = 4)  %>% colformat_double(j = c(1,6), digits = 0) %>%
  hline(i = c(6, 12), border = fp_border(style = "dashed")) %>% autofit()


# How many sea days are afforded by the each allocation scheme?
sea_days_afforded <- copy(allocation_gaps_CV$rates)[
][STRATA %in% c("HAL", "POT", "TRW")  
][, .SD[target_budgets, on = .(INDEX_COST), roll = "nearest"], by = .(ADP, STRATA)]
sea_days_afforded[, MEAN_TRIP_DAYS := trip_cost_dt[sea_days_afforded, MEAN_TRIP_DAYS, on = .(ADP, STRATA)]]
sea_days_afforded[, DAYS := MEAN_TRIP_DAYS * n]
sea_days_afforded <- sea_days_afforded[, .(TOTAL_SEA_DAYS = sum(DAYS)), keyby = .(INDEX_COST, ADP)]

sea_days_afforded_FMP <- copy(allocation_gaps_CV_FMP$rates)[
][STRATA %in% c("HAL", "POT", "TRW")  
][, .SD[target_budgets, on = .(INDEX_COST), roll = "nearest"], by = .(ADP, STRATA, FMP_MT)]
sea_days_afforded_FMP[, MEAN_TRIP_DAYS := trip_cost_dt[sea_days_afforded_FMP, MEAN_TRIP_DAYS, on = .(ADP, STRATA)]]
sea_days_afforded_FMP[, DAYS := MEAN_TRIP_DAYS * n]
sea_days_afforded_FMP <- sea_days_afforded_FMP[, .(TOTAL_SEA_DAYS_FMP = sum(DAYS)), keyby = .(INDEX_COST, ADP)]
sea_days_afforded_FMP

sea_days_afforded_tbl <- sea_days_afforded[sea_days_afforded_FMP, on = .(INDEX_COST, ADP)] %>%
  flextable() %>% colformat_double(j = c(3, 4), digits = 0)  %>% colformat_num(j = c(2), big.mark = "") %>%
  hline(i = c(4, 8), border = fp_border(style = "dashed")) %>% autofit()

#===============================================#
# Save objects for allocation_evaluation.Rmd ####
#===============================================#

save(
  allocation_gaps, allocation_gaps_tbl, allocation_gaps_CV, allocation_gaps_CV_tbl, 
  allocation_gaps_CV_FMP, allocation_gaps_CV__FMP_tbl, sea_days_afforded_tbl,
  file = "analyses/allocation_evaluation/allocation_evaluation_Rmd.Rdata"
)


#==================#
# Size of Cells ####
#==================#

nmfs_km2 <- as.numeric(shp_nmfs %>% st_area() / 1e6) # Area in square kilometers
grid_200km <- stat_area_to_hex(2e5, stat_area_sf)    # Generate a grid with the same extent as stat areas
grid_200km_area <- as.numeric(unique(round(grid_200km$HEX_GEOMETRY %>% st_area())) / 1e6)  # Area in square kilometers
hex_sub <- grid_200km$HEX_GEOMETRY %>% filter(HEX_ID %in% c(78, 67, 73, 85, 91, 84, 72))
hex_sub <- hex_sub %>% mutate(color = ifelse(HEX_ID == 78, "green", "purple"))

# Map with 200km grid
map_200km <- ggplot() + 
  geom_sf(data = shp_nmfs, color = "red", fill = NA) + 
  geom_sf(data = shp_land, fill = "gray") + 
  geom_sf(data = grid_200km$HEX_GEOMETRY, color = "blue", fill = NA) + 
  #geom_sf_text(data = grid_200km$HEX_GEOMETRY, aes(label = HEX_ID))
  geom_sf(data = hex_sub, aes(fill = I(color)), alpha = 0.5) + 
  theme(axis.text = element_blank(), axis.ticks = element_blank()) + 
  labs(subtitle = "Grid of 200km-wide hexagon cells.")

# Histogram of NMFS area extent in km2, with lines indicating area of box (red) and its neighbors (blue)
box_area_hist <- ggplot(data.table(Area = nmfs_km2)) + 
  geom_histogram(aes(x = Area)) + 
  geom_vline(xintercept = grid_200km_area, color = "green", size = 2) + 
  geom_vline(xintercept = grid_200km_area*7, color = "purple", size = 2) +
  scale_x_continuous() + 
  labs(x = bquote('Area '(km^2)), subtitle = "Histogram of extent of NMFS Areas. Green = box, Purple = box with 6 neighbors.")

ggsave(filename = "analyses/allocation_evaluation/figures/map_200km.png", map_200km, height = 6, width = 8, units = "in")
ggsave(filename = "analyses/allocation_evaluation/figures/box_area_hist.png", box_area_hist, height = 4, width = 8, units = "in")


grid_200km_area
grid_200km_area*7



#========================#
# Cost-Weighted Boxes ####
#========================#

trip_cost_dt

# According to the ADP Analytic Plan:  It uses a variation on Neyman allocation which minimizes the proportion of 
# post-strata with no data for a given budget.
# Neyman allocation is a special case of optimal allocation where the costs per unit are the same for all strata (THIS IS NOT TRUE!)
# Optimal allocation balances stratum costs, variance, and stratum sizes. Do I just replace variance with prop_box?

# So instead of MEAN_PROP_N, need to calculate NUMBER OF BOXES likely to be sampled.
# Should be able to do this mathematically? 
# TODO Simulate sampling to calculate proportion of boxes sampled?
# Or instead of MEAN_PROP_N, simply get the average probability that each box is sampled? Compare with simulated results!

cwb_prop <- calculate_mean_prop_box(box_def, sample_rate_vec)

# For each year, see how sample rate affects the average proportion of boxes likely to be sampled.
ggplot(cwb_prop, aes(x = SAMPLE_RATE, y = MEAN_PROP_BOX, color = STRATA)) + facet_grid(. ~ ADP) + geom_line(size = 1) +
  theme(legend.position = "bottom") + scale_x_continuous(limits  = c(0, 0.5)) + geom_vline(xintercept = 0.15)

# https://documentation.sas.com/doc/en/statcdc/14.2/statug/statug_surveyselect_details22.htm
# (Nh * Sh / sqrt(Ch)) / sum[ (Ni * Si) / sqrt(Ci) ]
# With optimal allocation, 'variance' is a known quantity to plug into the formula. Here, we just brute force it such that 
# prop_box is the same for all strata?

# Or do I simply weigh by MEAN_PROP_BOX / sqrt(CPT), not N?

# normally, S (variance) is a numerator so that we try to allocate more samples to higher-variance strata
# However, MEAN_PROP_BOX is 'better' is it increases, so put it in the denominator?

test <- trip_cost_dt[cwb_prop, on = .(ADP, STRATA)]

# (N * (prob no samples)) / sqrt (trip cost)
test[, NP_C := N * (1-MEAN_PROP_BOX)  / sqrt(CPT)]
# But now which NP_S do I use? What rate do I assume? What am I allocating on? MEAN_PROP_BOX depends on the sample rate!
# Do I allocate such that 1 - MEAN_PROP_BOX is equal for all strata?
# sumH ( Nh * Ph / Sh )

npc_range <- test[
][, setNames(as.list(range(NP_C)), c("MIN", "MAX")), by = ADP
][, .(MIN = max(MIN), MAX = min(MAX)), by = c("ADP")]

# For each year, create a vector of NPC that is the same for all strata
npc_dt <- apply(npc_range, 1, function(x) {
  # Could go up to 1e5 or even higher if you want more resolution, but plotting will be very slow!
  npc_vector <- data.table(ADP = x[["ADP"]], NP_C = seq(x[["MIN"]], x[["MAX"]], by = (x[["MAX"]] - x[["MIN"]])/1e4))
})

npc_join <- rbindlist(lapply(npc_dt, function(x) test[, .SD[x, on = .(ADP, NP_C), roll = "nearest"], by = .(STRATA)]))

what <- test[ADP==2022 & SAMPLE_RATE == 0.15]  # Assume an equivalent sample rate for all strata?
what[, wh := NP_C / sum(NP_C)]
what  # wH here would then be my sample rate? But can I even afford these? What am I maximizing/minimizing?

test[ADP==2022 & SAMPLE_RATE == 0.2][, wh := NP_C / sum(NP_C)][]  #If I assume a 20% rate, similar, but OB_POT changed a lot
test[ADP==2022 & SAMPLE_RATE == 0.3][, wh := NP_C / sum(NP_C)][]
test[ADP==2022 & SAMPLE_RATE == 0.4][, wh := NP_C / sum(NP_C)][]
# in NP_C, N basically just makes it so we allocate proportionately to sample size.
# C (sqrt(cost)) makes it so we allocate more to strata with lower cost per sample
# P here should be a general metric of the expected proportion of boxes that WONT be sampled, but it has to assume a rate
# a rate that we are trying to decide on!) Should we use the rate that would be afforded under equal rates?
# If we assume a $4,5M budget...
cost_2022 <- unique(test[ADP == 2022, .(STRATA, N, CPT)])[, EQUAL_RATE := 4.5e6 / sum(N*CPT)][] # 0.1469 afforded for all strata
test[ADP==2022 & SAMPLE_RATE == 0.1469][, wh := NP_C / sum(NP_C)][]

# TRW gear trips generally have boxes filled easily and are cheaper
# FIXME Are these MEAN_PROP_BOX really accurate? OB_POT is as good as OB_TRW and EM_TRW?
a <- copy(index_res$rates)
a <- index_res$rates[, .SD[data.table(ADP = 2022, SAMPLE_RATE = 0.1469), roll = T, on = .(ADP, SAMPLE_RATE)], by = .(STRATA)  ]
a # With sample rates of 0.1469, ISPN is fairly high for all strata except for EM_POT...







# TODO This is just how the new box definition works... might need to re-evaluate the definition we use, since we've 
# fundamentally changed how it works with allowing time to vary!
# TODO Now that time is allowed to overlap to a greater degree, proximity is easier, and time is relatively more effective than
# space. Should I be using a 5-day window instead of 7 to balance it out?
# A 15% sample rate ideally wouldn't result in 95% overlap for basically all strata... little resolution for gaps?
date_range <- 1:1200
cut(date_range, breaks = seq(1, 1200, 5), include.lowest = T, labels = F)  # easy way to convert date to 5-day interval









# FIXME I don't know what I'm doing here!

test[, STRATUM_NSC := 1 / MEAN_PROP_BOX * sqrt(CPT)]
setattr(test, "stratum_cols", attr(cwb_prop, "stratum_cols"))

nsc_range <- test[
][, setNames(as.list(range(STRATUM_NSC)), c("MIN", "MAX")), by = c(attr(test, "stratum_cols"), "N")
][, .(MIN = max(MIN), MAX = min(MAX)), by = c("ADP")]

nsc_dt <- apply(nsc_range, 1, function(x) {
  # Could go up to 1e5 or even higher if you want more resolution, but plotting will be very slow!
  nsc_vector <- data.table(ADP = x[["ADP"]], STRATUM_NSC = seq(x[["MIN"]], x[["MAX"]], by = (x[["MAX"]] - x[["MIN"]])/1e4))
})
nsc_join <- rbindlist(lapply(nsc_dt, function(x) test[, .SD[x, on = .(ADP, STRATUM_NSC), roll = "nearest"], by = .(STRATA)]))
setkey(nsc_join, ADP, STRATUM_NSC, STRATA)
nsc_join
# TODO This was super fast! Do I use this same syntax for the prior joins?

nsc_join[, STRATUM_NSC := N * MEAN_PROP_BOX / sqrt(CPT)]  

nsc_join[, TOTAL_NSC := sum(STRATUM_NSC), by = .(ADP, MEAN_PROP_BOX)]
nsc_join[, Wh := STRATUM_NSC / TOTAL_NSC]
nsc_join[, TOTAL_COST := sum(N * SAMPLE_RATE * CPT), by = .(ADP, MEAN_PROP_BOX)]

# Find what rates afford a $4M program
test2 <- data.table(ADP = 2021, TOTAL_COST = 4e6)
nsc_join[, .SD[test2, on = .(ADP, TOTAL_COST), roll = "nearest"], by = .(STRATA)]  # Approx 0.795%
# TODO Why is TOTAL_NSC more than sum of stratum_NSC?

#===============#
# Boxes Only ####
#===============#

# FIXME Rename all variabes below from cwb (cost-weighted-boxes) to something else like 'box_only'

cwb_range <- cwb_prop[
][, setNames(as.list(range(MEAN_PROP_BOX)), c("MIN", "MAX")), by = c(attr(cwb_prop, "stratum_cols"), "N")
][, .(MIN = max(MIN), MAX = min(MAX)), by = c("ADP")]

cwb_dt <- apply(cwb_range, 1, function(x) {
  # Could go up to 1e5 or even higher if you want more resolution, but plotting will be very slow!
  cwb_vector <- data.table(ADP = x[["ADP"]], MEAN_PROP_BOX = seq(x[["MIN"]], x[["MAX"]], by = (x[["MAX"]] - x[["MIN"]])/1e4))
})
cwb_join <- rbindlist(lapply(cwb_dt, function(x) cwb_prop[, .SD[x, on = .(ADP, MEAN_PROP_BOX), roll = "nearest"], by = .(STRATA)]))
# TODO This was super fast! Do I use this same syntax for the prior joins?
ggplot(cwb_join, aes(x = SAMPLE_RATE, y = MEAN_PROP_BOX, color = STRATA)) + geom_line(size = 1) + facet_grid(. ~ ADP)

cwb_join <- cwb_join[trip_cost_dt, on = .(ADP, STRATA)]   # Merge in cost of sampling each stratum
setkey(cwb_join, ADP, MEAN_PROP_BOX, ADP)

cwb_join[, STRATUM_NSC := N * MEAN_PROP_BOX / sqrt(CPT)]  
cwb_join[, TOTAL_NSC := sum(STRATUM_NSC), by = .(ADP, MEAN_PROP_BOX)]
cwb_join[, Wh := STRATUM_NSC / TOTAL_NSC]
cwb_join[, TOTAL_COST := sum(N * SAMPLE_RATE * CPT), by = .(ADP, MEAN_PROP_BOX)]

# Find what rates afford a $4M program
test <- data.table(ADP = 2021, TOTAL_COST = 4e6)
cwb_join[, .SD[test, on = .(ADP, TOTAL_COST), roll = "nearest"], by = .(STRATA)]  # Approx 0.795%
# Wait.. this wasn't weighted by cost tho... 
# FIXME START OVER! Calculate STRATUM_NSC for full range, then find overlapping ranges, etc?
# I tink what I did above was weighbted by box only



#======================================#
# Compare rates at $4M program size ####
#======================================#

# Note that since I've allowed trips to belong to multiple weeks (instead of week centered on start and end), overlap increased,
# So HAL is 
dcast(
  allocation_gaps_CV$rates[, .SD[findInterval(4e6, INDEX_COST)], by = c(attr(allocation_gaps_CV, "stratum_cols"))],
  STRATA ~ ADP, value.var = c("SAMPLE_RATE")
)

dcast(
  allocation_gaps$rates[, .SD[findInterval(4e6, INDEX_COST)], by = c(attr(allocation_gaps_CV, "stratum_cols"))],
  STRATA ~ ADP, value.var = c("SAMPLE_RATE")
)

allocation_gaps_CV$rates[, .SD[findInterval(4e6, INDEX_COST)], by = c(attr(allocation_gaps_CV, "stratum_cols"))][ADP==2021]
allocation_gaps$rates[, .SD[findInterval(4e6, INDEX_COST)], by = c(attr(allocation_gaps, "stratum_cols"))][ADP==2021]
# Can see that without CV, TRW and EM_TRW rates a significantly lower, resulting in higher coverage on other strata except for EM_POT

# TODO Mean_Prop N, CV scaling
allocation_gaps_CV$rates[, .SD[findInterval(4e6, INDEX_COST)], by = c(attr(allocation_gaps_CV, "stratum_cols"))][ADP==2021][, lapply(.SD, mean), .SDcols = c("MEAN_PROP_N_IN_SAMPLED_PS", "CV_SCALING")]
allocation_gaps$rates[, .SD[findInterval(4e6, INDEX_COST)], by = c(attr(allocation_gaps, "stratum_cols"))][ADP==2021][, lapply(.SD, mean), .SDcols = c("MEAN_PROP_N_IN_SAMPLED_PS", "CV_SCALING")]
# Keeping the STRATA un-scaled, both gaps are better (higher) and CV_scaling is better (lower) 

# TODO Scaled by stratum size, it's still better! Should scale by STRATUM size if you want to make comparisons with other stratum definitions too?
allocation_gaps_CV$rates[, .SD[findInterval(4e6, INDEX_COST)], by = c(attr(allocation_gaps, "stratum_cols"))][ADP==2021][, lapply(.SD, weighted.mean, N), .SDcols = c("MEAN_PROP_N_IN_SAMPLED_PS", "CV_SCALING")]
allocation_gaps$rates[, .SD[findInterval(4e6, INDEX_COST)], by = c(attr(allocation_gaps, "stratum_cols"))][ADP==2021][, lapply(.SD, weighted.mean, N), .SDcols = c("MEAN_PROP_N_IN_SAMPLED_PS", "CV_SCALING")]
# By including CV scaling, MEAN_PROP_N for EM_TRW and TRW can increase greatly. Without CV_scaling in the allocation, EM_TRW and TRW have huge (bad) CV_SCALING values even when weighted by N
# This shows that by putting more samples into TRW, you get fairly cost-efficient benefits to both MEAN_PROP_N and especially CV_SCALING


#==========================================#
# How many Observer Days can we expect? ####
#==========================================#

allocation_gaps_CV$rates[, .SD[findInterval(4e6, INDEX_COST)], by = .(ADP, STRATA)][ADP == 2022]
allocation_gaps_CV$rates[, .SD[findInterval(4.5e6, INDEX_COST)], by = .(ADP, STRATA)][ADP == 2022]

# Question: Are the costs here realistic? are we affording 2000 sea days?

test <- allocation_gaps_CV$rates[, .SD[findInterval(4e6, INDEX_COST)], by = .(ADP, STRATA)][ADP == 2022]
test <- trip_cost_dt[test[, -"CPT"], on = .(ADP, STRATA)]
test[, DAYS := n*MEAN_TRIP_DAYS]
test[, .(DOLLARS = sum(CPT*n), PROP_DOLLARS = sum(DOLLARS = sum(CPT*n)) / unique(INDEX_COST), DAYS = sum(DAYS)), by = (EM = STRATA %like% "EM")]  
# $4M, Only 1775 sea days with $4M program, $1.4M to EM. 
# Attributing more the Observers may be a good idea...

test <- allocation_gaps_CV$rates[, .SD[findInterval(4.5e6, INDEX_COST)], by = .(ADP, STRATA)][ADP == 2022]
test <- trip_cost_dt[test[, -"CPT"], on = .(ADP, STRATA)]
test[, DAYS := n*MEAN_TRIP_DAYS]
test[, .(DOLLARS = sum(CPT*n), PROP_DOLLARS = sum(DOLLARS = sum(CPT*n)) / unique(INDEX_COST), DAYS = sum(DAYS)), by = (EM = STRATA %like% "EM")]   
# $4.5M program, 2007 sea days. $1.6M to EM

test <- allocation_gaps_CV_FMP$rates[, .SD[findInterval(4e6, INDEX_COST)], by = .(ADP, STRATA, BSAI_GOA)][ADP == 2022]
test <- trip_cost_dt[test[, -"CPT"], on = .(ADP, STRATA)]
test[, DAYS := n*MEAN_TRIP_DAYS]
test[, .(DOLLARS = sum(CPT*n), PROP_DOLLARS = sum(DOLLARS = sum(CPT*n)) / unique(INDEX_COST), DAYS = sum(DAYS)), by = (EM = STRATA %like% "EM")]    
# $4M, splitting by FMP, 1866 sea days, so splitting by FMP puts more into observers

test <- allocation_gaps_CV_FMP$rates[, .SD[findInterval(4.5e6, INDEX_COST)], by = .(ADP, STRATA, BSAI_GOA)][ADP == 2022]
test <- trip_cost_dt[test[, -"CPT"], on = .(ADP, STRATA)]
test[, DAYS := n*MEAN_TRIP_DAYS]
test[, .(DOLLARS = sum(CPT*n), PROP_DOLLARS = sum(DOLLARS = sum(CPT*n)) / unique(INDEX_COST), DAYS = sum(DAYS)), by = (EM = STRATA %like% "EM")]   
# $4M, splitting by FMP, 2110 sea days

# 3M only 

test <- allocation_gaps_CV$rates[, .SD[findInterval(3e6, INDEX_COST)], by = .(ADP, STRATA)][ADP == 2022]
test <- trip_cost_dt[test[, -"CPT"], on = .(ADP, STRATA)]
test[, DAYS := n*MEAN_TRIP_DAYS]
test[, .(DOLLARS = sum(CPT*n), PROP_DOLLARS = sum(DOLLARS = sum(CPT*n)) / unique(INDEX_COST), DAYS = sum(DAYS)), by = (EM = STRATA %like% "EM")]   
# $3M program, 1322 sea days with, no splitting by FMP

test <- allocation_gaps_CV_FMP$rates[, .SD[findInterval(3e6, INDEX_COST)], by = .(ADP, STRATA, BSAI_GOA)][ADP == 2022]
test <- trip_cost_dt[test[, -"CPT"], on = .(ADP, STRATA)]
test[, DAYS := n*MEAN_TRIP_DAYS]
test[, .(DOLLARS = sum(CPT*n), PROP_DOLLARS = sum(DOLLARS = sum(CPT*n)) / unique(INDEX_COST), DAYS = sum(DAYS)), by = (EM = STRATA %like% "EM")]   
# $3M program splitting by FMP, 1384 sea days with 

# 2018: $3.3M (and most years prior to this were all higher, $4.3M in 2013)
# 2019: $2.8M
# 2020: $2.4M
# 2021: $3.2M - Fees now being collected at 1.65% (up from 1.25%)
# 2022: $4.5M projected

# With a $4M Budget and allocating $1M to fixed-gear EM and $3M to observers
a <- copy(allocation_gaps_CV$rates)
a[, NON_FGEM_COST := sum(CPT[!(STRATA %in% c("EM_HAL", "EM_POT"))] * n[!(STRATA %in% c("EM_HAL", "EM_POT"))]), by = INDEX]
a <- a[, .SD[findInterval(3e6, NON_FGEM_COST)], by = .(ADP, STRATA)][ADP == 2022]
a <- trip_cost_dt[a[, -"CPT"], on = .(ADP, STRATA)]
a[, DAYS := n*MEAN_TRIP_DAYS]
a[, .(DOLLARS = sum(CPT*n), PROP_DOLLARS = sum(DOLLARS = sum(CPT*n)) / unique(INDEX_COST), DAYS = sum(DAYS)), by = (EM = STRATA %like% "EM")]   
# $4M budget 1958 sea days, $3M to observers (EM_POT is just around 30% but EM_HAL is only 17.7%, and FG_EM cost is $1.4M)

# 2055 sea days with $4M program, so not likely to get much cost-efficiency from optional days!
# Assuming these cost estimates are reasonable, might make sense to not have a 2000 day minimum if we can avoid it...

#====================#
# Stratify by FMP ####
#====================#

effort_fmp <- unique(val_2018_2021_dt[
][STRATA != "ZERO" 
][, FMP := ifelse(NMFS_AREA > 600, "GOA", "BSAI")
][, .(ADP, STRATA, FMP, ADFG_STAT_AREA_CODE, WEEK, GEAR, TRIP_ID)
][ADFG_STAT_AREA_CODE == 515832, ADFG_STAT_AREA_CODE := 515831        # 515832 is missing from shape file
][, TRIP_ID := .GRP, by = .(TRIP_ID)])
ps_fmp <- define_poststrata(effort_fmp, space = c(1.75e5, 1.75e5*1), time = c("WEEK", 1), stratum_cols = c("ADP", "STRATA", "FMP"))

ps_fmp_prop_n <- calculate_mean_prop_n(ps_fmp, sample_rate_vec)  
ps_fmp_index <- calculate_index(ps_fmp_prop_n, trip_cost_dt)
# If we stratify by STRATA and FMP, what rates would $4M give us?
ps_fmp_index$rates[, .SD[findInterval(4e6, INDEX_COST)], by = .(ADP, STRATA, FMP)][ADP == 2021]  # make sure 'by' is same as 'stratum_cols' attribute!

# How does number of monitored trips per strata change?
ps_fmp_index$rates[, .SD[findInterval(4e6, INDEX_COST)], by = .(ADP, STRATA, FMP)][ADP == 2021][, .(n  = sum(n)), keyby = .(STRATA)]
s175_1_tW_1_index$rates[, .SD[findInterval(4e6, INDEX_COST)], by = .(ADP, STRATA)][ADP == 2021][order(STRATA)]
# Hmm, splitting by FMP results in more coverage for POT, but less for EM_HAL and EM_TRW

# FIXME Some trips fished in both FMP and BSAI - I didnt split there before, so in 2021 there were 4322 total trips
# whereas there are only 4271 unique TRIP_IDs!. Can't use val_2018_2021_dt for this, have to remake it, splitting by FMP by tonnage?
multi_fmp <- effort_fmp[, .SD[uniqueN(FMP) > 1,], by = .(TRIP_ID)]
multi_fmp[, .(MULTI_FMP_TRIP = uniqueN(TRIP_ID)), keyby = .(STRATA, ADP)]  #Most multi-FMP trips are in HAL and EM_HAL
# Separating BS and AI (instead of BSAI together) would create more strata, likely wouldn't help much?



