# Cost-weighted boxes exploration

library(data.table)         # Data wrangling
library(ggplot2)            # Plotting
library(sf)                 # Spatial analyses
library(dplyr)              # Data wrangling sf objects
library(flextable)          # Nicer tables in RMarkdown
library(officer)            # Better formatting of flextables
library(gridExtra)          # For combining plots and saving multiple figures to a single PDF

#============================#
# Load data and data prep ####
#============================#

# Fishing effort data from 2018 to 2021
# `spatiotemporal_boxes.rdata' is generated by /analyses/spatiotemporal_boxes/data_prep.R
load("analyses/allocation_evaluation/allocation_evaluation.RData")   # loads val_2018_2022_dt and in the future, trips_melt

# Load the ADFG statistical area shapefile. '../' is needed for Rmarkdown to climb into parent folders.
stat_area_sf <- st_read(
  dsn = "source_data/ADFG_Stat_Area_shapefile/PVG_Statewide_2001_Present_GCS_WGS1984.shp", quiet = T) %>%
  select(STAT_AREA) %>%
  st_transform(crs = 3467)

# Load the Alaska map sf objects
load("source_data/ak_shp.rdata")      # shp_land, shp_nmfs, and shp_centroids added to global

#===============#
# Trip Costs ####
#===============#

# Use average values from the 2023 Final ADP for now. Also, roughly using trip_end - trip_start + 1 for now until we get
# a better handle on future monitoring costs.
ob_cpd <- 4896623 / 3094         # $1582.619/day
fgem_cpd <- 1e6 / (1040+735)     # $ 563.380/day
trwem_cpd <- 600                 # $600/day according to JF estimates used in set_budget.R in 2022 Final ADP repo
# Get average trip length for all strata, using TRIP_END - TRIP_START + 1
# This function counts number of unique days between each trip target date and landing date
# use this to count days for non-observed trips, which already have a modeled 'DAYS' estimate.
day_count <- function(x) {
  length(unique(unlist(apply(x, 1, function(y) as.numeric(as.Date(y[1])) : as.numeric(as.Date(y[2])), simplify = F))))
}
val_2018_2022_dt[POOL != "OB", DAYS := day_count(.SD), by = .(TRIP_ID), .SDcols = c("TRIP_TARGET_DATE", "LANDING_DATE")]
trip_cost_dt <- unique(val_2018_2022_dt[, .(ADP, STRATA, TRIP_ID, DAYS)])[, .(MEAN_TRIP_DAYS = mean(DAYS)), by = .(ADP, STRATA)]
# trip_cost_dt <- unique(val_2018_2022_dt[STRATA != "ZERO", .(ADP, STRATA, TRIP_ID, START, END)])[
# ][, .(MEAN_TRIP_DAYS = mean(as.numeric(END - START, units = "days") + 1)), by = .(ADP, STRATA)]
# Merge in day costs
trip_cost_dt[, CPD := fcase(
  STRATA == "EM_TRW", trwem_cpd,
  STRATA %in% c("EM_POT", "EM_HAL"), fgem_cpd,
  STRATA %in% c("OB_HAL", "OB_POT", "OB_TRW"), ob_cpd)]
# Calculate cost per trip
trip_cost_dt[, CPT := MEAN_TRIP_DAYS * CPD]
trip_cost_dt[STRATA == "ZERO", ':=' (CPD = 0, CPT = 0)]

#===================#
# Load Functions ####
#===================#

source("analyses/allocation_evaluation/functions.R")    

#=========================#
# Apply Box Definition ####
#=========================#

# We'll be using 250km-wide hexagon cells as our spatial unit and 1-week bins. Neighbors are defined as trips in 
# adjacent spatial cells and in adjacent weeks.

# In terms of how we will evaluate the overlap between the observer pool with fixed-gear EM and zero, we will consider
# the gear types separately (i.e. post-stratify by GEAR). Additionally, we can include 'FMP' as a post-stratum so that
# we can quantify the overlap between the BSAI and GOA separately.

system.time(box_res <- define_boxes(
  val_2018_2022_dt, c(2.5e5, 2.5e5), time = c("week", 1, "TRIP_TARGET_DATE", "LANDING_DATE"),
  year_col = "ADP", stratum_cols = "STRATA", dmn_cols = c("BSAI_GOA", "GEAR")))

# What rate would be afforded in 2022 using equal rates and a $4.5M budget?
equal_rate_2022 <- trip_cost_dt[box_res$strata_n_dt, on = .(ADP, STRATA)
][ADP == 2022 , .(STRATA, STRATA_N, CPT)
][, EQUAL_RATE := 4.5e6 / sum(STRATA_N*CPT)][, unique(EQUAL_RATE)] # 0.1469 afforded for all strata

# Calculate expected proportion of sampled boxes for a range of sample rates
sample_rate_vec <- seq(from = 0.005, to = 0.95, by = 0.0001) 
# cwb_prop <- calculate_interspersion_cwb(box_res, sample_rate_vec)
cwb_prop <- calculate_cwb_Ph(box_res, sample_rate_vec)

target_budget <- 4.5e6

equal_rate_Ph <- cwb_prop$Ph_dt[SAMPLE_RATE == round(equal_rate_2022, 3)][STRATA != "ZERO"]
equal_rate_Ph[, CPT := trip_cost_dt[equal_rate_Ph, CPT, on = .(ADP, STRATA)]]  # Merge in cost per trip

# All make a function to quickly re-allocated
chunk_numbers <- function(x, target_budget) {
  x[, `NP/c_h` := (STRATA_N * Ph) / sqrt(CPT)       # Calculate NP/c for each stratum (numerator of equation 5.23)
  ][, `nh/n` := `NP/c_h` / sum(`NP/c_h`), by = .(ADP)        # # Calculate the optimal sample size (equation 5.23)
  ][, n := (target_budget * sum(`NP/c_h`)) / sum(STRATA_N * Ph * sqrt(CPT)), by = .(ADP)   # calculate afforded total sample size (equation 5.24)
  ][, nh := `nh/n` * n       # Calculate the optimal sample size of each stratum n_h using n_h/n * n
  ][, fh := nh / STRATA_N]   # using n_h / N_h, calculate allocated sample rate (sample fraction)
  setkey(x, ADP, STRATA)
  x
}
chunk_numbers(equal_rate_Ph, target_budget)

# This has fh for all years
equal_rate_Ph

# Use this table to look-up the Ph value for each ADP x STRATA given the adjusted sampling rate
cwb_prop$Ph_dt  # table of Ph values for each STRATA x YEAR

# Adjust sample_rate to be half of diff between sample_rate and N_h/N
half_diff <- function(x, Ph_dt, target_budget) {
  x <- copy(x)
  x[, SAMPLE_RATE := round(SAMPLE_RATE + (round(fh,3) - SAMPLE_RATE)/2, 3)]  # Adjust the sample rate to half the difference with N_h/N
  x[, Ph := Ph_dt[x, Ph, on = .(STRATA, ADP, SAMPLE_RATE)]]     #update Ph values using new sample rates
  chunk_numbers(x, target_budget)
  print(x)
}

# run this a couple times until 
step1 <- half_diff(equal_rate_Ph, cwb_prop$Ph_dt, target_budget)
step2 <- half_diff(step1, cwb_prop$Ph_dt, target_budget)
step3 <- half_diff(step2, cwb_prop$Ph_dt, target_budget)
step4 <- half_diff(step3, cwb_prop$Ph_dt, target_budget)
step5 <- half_diff(step4, cwb_prop$Ph_dt, target_budget)
step6 <- half_diff(step5, cwb_prop$Ph_dt, target_budget)
step7 <- half_diff(step6, cwb_prop$Ph_dt, target_budget)

combine_results <- function(step_list) {
  # step_list <- list(equal_rate_Ph, step1, step2, step3, step4, step5)
  
  step_nrow <- unique(sapply(step_list, nrow))
  if(length(step_nrow) > 1) stop("The number of rows in each step is not equal!")
  step <- rep(0:(length(step_list) - 1), each = step_nrow)
  cbind(Step = step, do.call(rbind, step_list))
}

cwb_results <- combine_results(list(equal_rate_Ph, step1, step2, step3, step4, step5, step6, step7))

ggplot(cwb_results, aes(x = Step, color = STRATA)) + theme(legend.position = "bottom") + 
  facet_grid(. ~ ADP) + 
  geom_line(aes(y = SAMPLE_RATE), linetype = 2, lwd = 1) + 
  geom_line(aes(y = fh), lwd = 1) + labs(subtitle = 'Dashed is assumed rate, solid is allocated rate')
  
#=================================================#
# What if I give it a different starting rate? ####
#=================================================#

if(F) {
  
  # Do I still get basically the same answers?
  
  og_results <- copy(cwb_results)  # Create a copy of the original results
  
  # Give it a new starting rate, say, 5%
  new_rate <- 0.5
  new_rate_Ph <- cwb_prop$Ph_dt[SAMPLE_RATE == round(new_rate, 3)][STRATA != "ZERO"]
  new_rate_Ph[, CPT := trip_cost_dt[equal_rate_Ph, CPT, on = .(ADP, STRATA)]]  # Merge in cost per trip
  
  chunk_numbers(new_rate_Ph, target_budget)
  new_rate_Ph
  
  new_step1 <- half_diff(new_rate_Ph, cwb_prop$Ph_dt, target_budget)
  new_step2 <- half_diff(new_step1, cwb_prop$Ph_dt, target_budget)
  new_step3 <- half_diff(new_step2, cwb_prop$Ph_dt, target_budget)
  new_step4 <- half_diff(new_step3, cwb_prop$Ph_dt, target_budget)
  new_step5 <- half_diff(new_step4, cwb_prop$Ph_dt, target_budget)
  new_cwb_results <- combine_results(list(new_rate_Ph, new_step1, new_step2, new_step3, new_step4, new_step5))
  
  cwb_results[ADP == 2022 & Step == 5]   # Yup pretty dang close! Getting an exact match isn't likely to happen though.
  new_cwb_results[ADP == 2022 & Step == 5]
  
  # Looks like the starting point doesn't matter!
  ggplot(rbind(cbind(cwb_results, START = paste0(round(equal_rate_2022,4)*100, "%")), cbind(new_cwb_results, START = paste0(new_rate*100, "%"))), aes(x = Step, color = START)) + theme(legend.position = "bottom") + 
    facet_grid(STRATA ~ ADP) + 
    geom_line(aes(y = fh), linetype = 2, lwd = 1) + 
    geom_line(aes(y = fh), lwd = 1) + labs(subtitle = 'Dashed is assumed rate, solid is allocated rate')
  
}

# Save outputs for the markdown!
save(
  equal_rate_2022, target_budget, equal_rate_Ph, cwb_prop, cwb_results, step7,
  file = "analyses/allocation_evaluation/cost_weighted_boxes_exploration_Rmd.Rdata"
)

# TODO - Make a version that weights independent of cost? Simply Nh*Ph? Have to calculate 'n' somehow though since equation 